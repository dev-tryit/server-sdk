import type { AttachB2bTaxInvoiceFileError } from "../..//b2b/TaxInvoice/AttachB2bTaxInvoiceFileError"
import type { B2bTaxInvoice } from "../..//b2b/TaxInvoice/B2bTaxInvoice"
import type { B2bTaxInvoiceInput } from "../..//b2b/TaxInvoice/B2bTaxInvoiceInput"
import type { B2bTaxInvoiceKeyType } from "../..//b2b/TaxInvoice/B2bTaxInvoiceKeyType"
import type { B2bTaxInvoiceModificationCreateBody } from "../..//b2b/TaxInvoice/B2bTaxInvoiceModificationCreateBody"
import type { B2bTaxInvoiceModificationUpdateBody } from "../..//b2b/TaxInvoice/B2bTaxInvoiceModificationUpdateBody"
import type { CancelB2bTaxInvoiceIssuanceError } from "../..//b2b/TaxInvoice/CancelB2bTaxInvoiceIssuanceError"
import type { CancelB2bTaxInvoiceIssuanceResponse } from "../..//b2b/TaxInvoice/CancelB2bTaxInvoiceIssuanceResponse"
import type { CancelB2bTaxInvoiceRequestError } from "../..//b2b/TaxInvoice/CancelB2bTaxInvoiceRequestError"
import type { CancelB2bTaxInvoiceRequestResponse } from "../..//b2b/TaxInvoice/CancelB2bTaxInvoiceRequestResponse"
import type { CreateB2bFileUploadUrlError } from "../..//b2b/TaxInvoice/CreateB2bFileUploadUrlError"
import type { CreateB2bFileUploadUrlPayload } from "../..//b2b/TaxInvoice/CreateB2bFileUploadUrlPayload"
import type { DeleteB2bTaxInvoiceAttachmentError } from "../..//b2b/TaxInvoice/DeleteB2bTaxInvoiceAttachmentError"
import type { DeleteB2bTaxInvoiceError } from "../..//b2b/TaxInvoice/DeleteB2bTaxInvoiceError"
import type { DeleteB2bTaxInvoiceResponse } from "../..//b2b/TaxInvoice/DeleteB2bTaxInvoiceResponse"
import type { DraftB2bTaxInvoiceError } from "../..//b2b/TaxInvoice/DraftB2bTaxInvoiceError"
import type { DraftB2bTaxInvoiceResponse } from "../..//b2b/TaxInvoice/DraftB2bTaxInvoiceResponse"
import type { GetB2bTaxInvoiceAttachmentsError } from "../..//b2b/TaxInvoice/GetB2bTaxInvoiceAttachmentsError"
import type { GetB2bTaxInvoiceAttachmentsResponse } from "../..//b2b/TaxInvoice/GetB2bTaxInvoiceAttachmentsResponse"
import type { GetB2bTaxInvoiceError } from "../..//b2b/TaxInvoice/GetB2bTaxInvoiceError"
import type { GetB2bTaxInvoicePdfDownloadUrlError } from "../..//b2b/TaxInvoice/GetB2bTaxInvoicePdfDownloadUrlError"
import type { GetB2bTaxInvoicePdfDownloadUrlResponse } from "../..//b2b/TaxInvoice/GetB2bTaxInvoicePdfDownloadUrlResponse"
import type { GetB2bTaxInvoicePopupUrlError } from "../..//b2b/TaxInvoice/GetB2bTaxInvoicePopupUrlError"
import type { GetB2bTaxInvoicePopupUrlResponse } from "../..//b2b/TaxInvoice/GetB2bTaxInvoicePopupUrlResponse"
import type { GetB2bTaxInvoicePrintUrlError } from "../..//b2b/TaxInvoice/GetB2bTaxInvoicePrintUrlError"
import type { GetB2bTaxInvoicePrintUrlResponse } from "../..//b2b/TaxInvoice/GetB2bTaxInvoicePrintUrlResponse"
import type { GetB2bTaxInvoicesBodyFilter } from "../..//b2b/TaxInvoice/GetB2bTaxInvoicesBodyFilter"
import type { GetB2bTaxInvoicesError } from "../..//b2b/TaxInvoice/GetB2bTaxInvoicesError"
import type { GetB2bTaxInvoicesResponse } from "../..//b2b/TaxInvoice/GetB2bTaxInvoicesResponse"
import type { IssueB2bTaxInvoiceError } from "../..//b2b/TaxInvoice/IssueB2bTaxInvoiceError"
import type { IssueB2bTaxInvoiceResponse } from "../..//b2b/TaxInvoice/IssueB2bTaxInvoiceResponse"
import type { RefuseB2bTaxInvoiceRequestError } from "../..//b2b/TaxInvoice/RefuseB2bTaxInvoiceRequestError"
import type { RefuseB2bTaxInvoiceRequestResponse } from "../..//b2b/TaxInvoice/RefuseB2bTaxInvoiceRequestResponse"
import type { RequestB2bTaxInvoiceResponse } from "../..//b2b/TaxInvoice/RequestB2bTaxInvoiceResponse"
import type { RequestB2bTaxInvoiceReverseIssuanceError } from "../..//b2b/TaxInvoice/RequestB2bTaxInvoiceReverseIssuanceError"
import type { RequestB2bTaxInvoiceReverseIssuanceResponse } from "../..//b2b/TaxInvoice/RequestB2bTaxInvoiceReverseIssuanceResponse"
import type { SendToNtsB2bTaxInvoiceError } from "../..//b2b/TaxInvoice/SendToNtsB2bTaxInvoiceError"
import type { SendToNtsB2bTaxInvoiceResponse } from "../..//b2b/TaxInvoice/SendToNtsB2bTaxInvoiceResponse"
import type { UpdateB2bTaxInvoiceDraftError } from "../..//b2b/TaxInvoice/UpdateB2bTaxInvoiceDraftError"
import type { UpdateB2bTaxInvoiceDraftResponse } from "../..//b2b/TaxInvoice/UpdateB2bTaxInvoiceDraftResponse"
import type { requestB2bTaxInvoiceError } from "../..//b2b/TaxInvoice/requestB2bTaxInvoiceError"
import * as Errors from "../..//errors"
export type { AttachB2bTaxInvoiceFileBody } from "./AttachB2bTaxInvoiceFileBody"
export type { B2bSearchDateType } from "./B2bSearchDateType"
export type { B2bTaxInvoice } from "./B2bTaxInvoice"
export type { B2bTaxInvoiceAdditionalContact } from "./B2bTaxInvoiceAdditionalContact"
export type { B2bTaxInvoiceAttachment } from "./B2bTaxInvoiceAttachment"
export type { B2bTaxInvoiceCompany } from "./B2bTaxInvoiceCompany"
export type { B2bTaxInvoiceContact } from "./B2bTaxInvoiceContact"
export type { B2bTaxInvoiceDocumentModificationType } from "./B2bTaxInvoiceDocumentModificationType"
export type { B2bTaxInvoiceInput } from "./B2bTaxInvoiceInput"
export type { B2bTaxInvoiceIssuanceType } from "./B2bTaxInvoiceIssuanceType"
export type { B2bTaxInvoiceItem } from "./B2bTaxInvoiceItem"
export type { B2bTaxInvoiceKeyType } from "./B2bTaxInvoiceKeyType"
export type { B2bTaxInvoiceModification } from "./B2bTaxInvoiceModification"
export type { B2bTaxInvoiceModificationCreateBody } from "./B2bTaxInvoiceModificationCreateBody"
export type { B2bTaxInvoiceModificationType } from "./B2bTaxInvoiceModificationType"
export type { B2bTaxInvoiceModificationUpdateBody } from "./B2bTaxInvoiceModificationUpdateBody"
export type { B2bTaxInvoicePurposeType } from "./B2bTaxInvoicePurposeType"
export type { B2bTaxInvoiceStatus } from "./B2bTaxInvoiceStatus"
export type { B2bTaxInvoiceSummary } from "./B2bTaxInvoiceSummary"
export type { B2bTaxInvoiceTaxationType } from "./B2bTaxInvoiceTaxationType"
export type { CancelB2bTaxInvoiceIssuanceBody } from "./CancelB2bTaxInvoiceIssuanceBody"
export type { CancelB2bTaxInvoiceIssuanceResponse } from "./CancelB2bTaxInvoiceIssuanceResponse"
export type { CancelB2bTaxInvoiceRequestBody } from "./CancelB2bTaxInvoiceRequestBody"
export type { CancelB2bTaxInvoiceRequestResponse } from "./CancelB2bTaxInvoiceRequestResponse"
export type { CreateB2bFileUploadUrlBody } from "./CreateB2bFileUploadUrlBody"
export type { CreateB2bFileUploadUrlPayload } from "./CreateB2bFileUploadUrlPayload"
export type { DateRangeOption } from "./DateRangeOption"
export type { Decimal } from "./Decimal"
export type { DeleteB2bTaxInvoiceResponse } from "./DeleteB2bTaxInvoiceResponse"
export type { DraftB2bTaxInvoiceBody } from "./DraftB2bTaxInvoiceBody"
export type { DraftB2bTaxInvoiceResponse } from "./DraftB2bTaxInvoiceResponse"
export type { GetB2bTaxInvoiceAttachmentsResponse } from "./GetB2bTaxInvoiceAttachmentsResponse"
export type { GetB2bTaxInvoicePdfDownloadUrlResponse } from "./GetB2bTaxInvoicePdfDownloadUrlResponse"
export type { GetB2bTaxInvoicePopupUrlResponse } from "./GetB2bTaxInvoicePopupUrlResponse"
export type { GetB2bTaxInvoicePrintUrlResponse } from "./GetB2bTaxInvoicePrintUrlResponse"
export type { GetB2bTaxInvoicesBody } from "./GetB2bTaxInvoicesBody"
export type { GetB2bTaxInvoicesBodyDateFilter } from "./GetB2bTaxInvoicesBodyDateFilter"
export type { GetB2bTaxInvoicesBodyFilter } from "./GetB2bTaxInvoicesBodyFilter"
export type { GetB2bTaxInvoicesBodyPrimaryFilter } from "./GetB2bTaxInvoicesBodyPrimaryFilter"
export type { GetB2bTaxInvoicesResponse } from "./GetB2bTaxInvoicesResponse"
export type { IssueB2bTaxInvoiceBody } from "./IssueB2bTaxInvoiceBody"
export type { IssueB2bTaxInvoiceResponse } from "./IssueB2bTaxInvoiceResponse"
export type { RefuseB2bTaxInvoiceRequestBody } from "./RefuseB2bTaxInvoiceRequestBody"
export type { RefuseB2bTaxInvoiceRequestResponse } from "./RefuseB2bTaxInvoiceRequestResponse"
export type { RequestB2bTaxInvoiceResponse } from "./RequestB2bTaxInvoiceResponse"
export type { RequestB2bTaxInvoiceReverseIssuanceBody } from "./RequestB2bTaxInvoiceReverseIssuanceBody"
export type { RequestB2bTaxInvoiceReverseIssuanceResponse } from "./RequestB2bTaxInvoiceReverseIssuanceResponse"
export type { SendToNtsB2bTaxInvoiceResponse } from "./SendToNtsB2bTaxInvoiceResponse"
export type { UpdateB2bTaxInvoiceDraftBody } from "./UpdateB2bTaxInvoiceDraftBody"
export type { UpdateB2bTaxInvoiceDraftResponse } from "./UpdateB2bTaxInvoiceDraftResponse"
/** @ignore */
export function TaxInvoiceClient(secret: string, userAgent: string, baseUrl?: string, storeId?: string): TaxInvoiceClient {
	return {
		requestB2bTaxInvoiceReverseIssuance: async (
			options: {
				test?: boolean,
				taxInvoice: B2bTaxInvoiceInput,
				memo?: string,
				modification?: B2bTaxInvoiceModificationCreateBody,
			}
		): Promise<RequestB2bTaxInvoiceReverseIssuanceResponse> => {
			const {
				test,
				taxInvoice,
				memo,
				modification,
			} = options
			const requestBody = JSON.stringify({
				taxInvoice,
				memo,
				modification,
			})
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b/tax-invoices/request-reverse-issuance?${query}`, baseUrl),
				{
					method: "post",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
					body: requestBody,
				},
			)
			if (!response.ok) {
				const errorResponse: RequestB2bTaxInvoiceReverseIssuanceError = await response.json()
				switch (errorResponse.type) {
				case "B2B_CANNOT_CHANGE_TAX_TYPE":
					throw new Errors.B2BCannotChangeTaxTypeError(errorResponse)
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_ID_ALREADY_EXISTS":
					throw new Errors.B2bIdAlreadyExistsError(errorResponse)
				case "B2B_MODIFICATION_NOT_PROVIDED":
					throw new Errors.B2bModificationNotProvidedError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_ORIGINAL_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bOriginalTaxInvoiceNotFoundError(errorResponse)
				case "B2B_RECIPIENT_NOT_FOUND":
					throw new Errors.B2bRecipientNotFoundError(errorResponse)
				case "B2B_SUPPLIER_NOT_FOUND":
					throw new Errors.B2bSupplierNotFoundError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "B2B_TAX_INVOICE_RECIPIENT_DOCUMENT_KEY_ALREADY_USED":
					throw new Errors.B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError(errorResponse)
				case "B2B_TAX_INVOICE_STATUS_NOT_SENDING_COMPLETED":
					throw new Errors.B2BTaxInvoiceStatusNotSendingCompletedError(errorResponse)
				case "B2B_TAX_INVOICE_SUPPLIER_DOCUMENT_KEY_ALREADY_USED":
					throw new Errors.B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError(errorResponse)
				case "FORBIDDEN":
					throw new Errors.ForbiddenError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		getB2bTaxInvoice: async (
			options: {
				taxInvoiceKey: string,
				brn?: string,
				taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
				test?: boolean,
			}
		): Promise<B2bTaxInvoice> => {
			const {
				taxInvoiceKey,
				brn,
				taxInvoiceKeyType,
				test,
			} = options
			const query = [
				["brn", brn],
				["taxInvoiceKeyType", taxInvoiceKeyType],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b/tax-invoices/${taxInvoiceKey}?${query}`, baseUrl),
				{
					method: "get",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: GetB2bTaxInvoiceError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "FORBIDDEN":
					throw new Errors.ForbiddenError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		deleteB2bTaxInvoice: async (
			options: {
				taxInvoiceKey: string,
				brn?: string,
				taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
				test?: boolean,
			}
		): Promise<DeleteB2bTaxInvoiceResponse> => {
			const {
				taxInvoiceKey,
				brn,
				taxInvoiceKeyType,
				test,
			} = options
			const query = [
				["brn", brn],
				["taxInvoiceKeyType", taxInvoiceKeyType],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b/tax-invoices/${taxInvoiceKey}?${query}`, baseUrl),
				{
					method: "delete",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: DeleteB2bTaxInvoiceError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NON_DELETABLE_STATUS":
					throw new Errors.B2bTaxInvoiceNonDeletableStatusError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "FORBIDDEN":
					throw new Errors.ForbiddenError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		issueB2bTaxInvoice: async (
			options: {
				taxInvoiceKey: string,
				brn?: string,
				taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
				test?: boolean,
				memo?: string,
				emailSubject?: string,
			}
		): Promise<IssueB2bTaxInvoiceResponse> => {
			const {
				taxInvoiceKey,
				brn,
				taxInvoiceKeyType,
				test,
				memo,
				emailSubject,
			} = options
			const requestBody = JSON.stringify({
				memo,
				emailSubject,
			})
			const query = [
				["brn", brn],
				["taxInvoiceKeyType", taxInvoiceKeyType],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b/tax-invoices/${taxInvoiceKey}/issue?${query}`, baseUrl),
				{
					method: "post",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
					body: requestBody,
				},
			)
			if (!response.ok) {
				const errorResponse: IssueB2bTaxInvoiceError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_REQUESTED_STATUS":
					throw new Errors.B2bTaxInvoiceNotRequestedStatusError(errorResponse)
				case "B2B_TAX_INVOICE_NO_SUPPLIER_DOCUMENT_KEY":
					throw new Errors.B2bTaxInvoiceNoSupplierDocumentKeyError(errorResponse)
				case "FORBIDDEN":
					throw new Errors.ForbiddenError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		sendToNtsB2bTaxInvoice: async (
			options: {
				taxInvoiceKey: string,
				brn?: string,
				taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
				test?: boolean,
			}
		): Promise<SendToNtsB2bTaxInvoiceResponse> => {
			const {
				taxInvoiceKey,
				brn,
				taxInvoiceKeyType,
				test,
			} = options
			const query = [
				["brn", brn],
				["taxInvoiceKeyType", taxInvoiceKeyType],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b/tax-invoices/${taxInvoiceKey}/send-to-nts?${query}`, baseUrl),
				{
					method: "post",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: SendToNtsB2bTaxInvoiceError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_ISSUED_STATUS":
					throw new Errors.B2bTaxInvoiceNotIssuedStatusError(errorResponse)
				case "FORBIDDEN":
					throw new Errors.ForbiddenError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		cancelB2bTaxInvoiceRequest: async (
			options: {
				taxInvoiceKey: string,
				brn?: string,
				taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
				test?: boolean,
				memo?: string,
			}
		): Promise<CancelB2bTaxInvoiceRequestResponse> => {
			const {
				taxInvoiceKey,
				brn,
				taxInvoiceKeyType,
				test,
				memo,
			} = options
			const requestBody = JSON.stringify({
				memo,
			})
			const query = [
				["brn", brn],
				["taxInvoiceKeyType", taxInvoiceKeyType],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b/tax-invoices/${taxInvoiceKey}/cancel-request?${query}`, baseUrl),
				{
					method: "post",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
					body: requestBody,
				},
			)
			if (!response.ok) {
				const errorResponse: CancelB2bTaxInvoiceRequestError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_REQUESTED_STATUS":
					throw new Errors.B2bTaxInvoiceNotRequestedStatusError(errorResponse)
				case "B2B_TAX_INVOICE_NO_RECIPIENT_DOCUMENT_KEY":
					throw new Errors.B2bTaxInvoiceNoRecipientDocumentKeyError(errorResponse)
				case "FORBIDDEN":
					throw new Errors.ForbiddenError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		cancelB2bTaxInvoiceIssuance: async (
			options: {
				taxInvoiceKey: string,
				brn?: string,
				taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
				test?: boolean,
				memo?: string,
			}
		): Promise<CancelB2bTaxInvoiceIssuanceResponse> => {
			const {
				taxInvoiceKey,
				brn,
				taxInvoiceKeyType,
				test,
				memo,
			} = options
			const requestBody = JSON.stringify({
				memo,
			})
			const query = [
				["brn", brn],
				["taxInvoiceKeyType", taxInvoiceKeyType],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b/tax-invoices/${taxInvoiceKey}/cancel-issuance?${query}`, baseUrl),
				{
					method: "post",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
					body: requestBody,
				},
			)
			if (!response.ok) {
				const errorResponse: CancelB2bTaxInvoiceIssuanceError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_ISSUED_STATUS":
					throw new Errors.B2bTaxInvoiceNotIssuedStatusError(errorResponse)
				case "FORBIDDEN":
					throw new Errors.ForbiddenError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		refuseB2bTaxInvoiceRequest: async (
			options: {
				taxInvoiceKey: string,
				brn?: string,
				taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
				test?: boolean,
				memo?: string,
			}
		): Promise<RefuseB2bTaxInvoiceRequestResponse> => {
			const {
				taxInvoiceKey,
				brn,
				taxInvoiceKeyType,
				test,
				memo,
			} = options
			const requestBody = JSON.stringify({
				memo,
			})
			const query = [
				["brn", brn],
				["taxInvoiceKeyType", taxInvoiceKeyType],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b/tax-invoices/${taxInvoiceKey}/refuse-request?${query}`, baseUrl),
				{
					method: "post",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
					body: requestBody,
				},
			)
			if (!response.ok) {
				const errorResponse: RefuseB2bTaxInvoiceRequestError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_REQUESTED_STATUS":
					throw new Errors.B2bTaxInvoiceNotRequestedStatusError(errorResponse)
				case "B2B_TAX_INVOICE_NO_SUPPLIER_DOCUMENT_KEY":
					throw new Errors.B2bTaxInvoiceNoSupplierDocumentKeyError(errorResponse)
				case "FORBIDDEN":
					throw new Errors.ForbiddenError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		getB2bTaxInvoices: async (
			options?: {
				test?: boolean,
				pageNumber?: number,
				pageSize?: number,
				filter?: GetB2bTaxInvoicesBodyFilter,
			}
		): Promise<GetB2bTaxInvoicesResponse> => {
			const test = options?.test
			const pageNumber = options?.pageNumber
			const pageSize = options?.pageSize
			const filter = options?.filter
			const requestBody = JSON.stringify({
				test,
				pageNumber,
				pageSize,
				filter,
			})
			const query = [
				["requestBody", requestBody],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b/tax-invoices?${query}`, baseUrl),
				{
					method: "get",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: GetB2bTaxInvoicesError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "FORBIDDEN":
					throw new Errors.ForbiddenError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		getB2bTaxInvoicePopupUrl: async (
			options: {
				taxInvoiceKey: string,
				brn?: string,
				taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
				includeMenu?: boolean,
				test?: boolean,
			}
		): Promise<GetB2bTaxInvoicePopupUrlResponse> => {
			const {
				taxInvoiceKey,
				brn,
				taxInvoiceKeyType,
				includeMenu,
				test,
			} = options
			const query = [
				["brn", brn],
				["taxInvoiceKeyType", taxInvoiceKeyType],
				["includeMenu", includeMenu],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b/tax-invoices/${taxInvoiceKey}/popup-url?${query}`, baseUrl),
				{
					method: "get",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: GetB2bTaxInvoicePopupUrlError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "FORBIDDEN":
					throw new Errors.ForbiddenError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		getB2bTaxInvoicePrintUrl: async (
			options: {
				taxInvoiceKey: string,
				brn?: string,
				taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
				test?: boolean,
			}
		): Promise<GetB2bTaxInvoicePrintUrlResponse> => {
			const {
				taxInvoiceKey,
				brn,
				taxInvoiceKeyType,
				test,
			} = options
			const query = [
				["brn", brn],
				["taxInvoiceKeyType", taxInvoiceKeyType],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b/tax-invoices/${taxInvoiceKey}/print-url?${query}`, baseUrl),
				{
					method: "get",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: GetB2bTaxInvoicePrintUrlError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "FORBIDDEN":
					throw new Errors.ForbiddenError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		getB2bTaxInvoicePdfDownloadUrl: async (
			options: {
				taxInvoiceKey: string,
				brn?: string,
				taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
				test?: boolean,
			}
		): Promise<GetB2bTaxInvoicePdfDownloadUrlResponse> => {
			const {
				taxInvoiceKey,
				brn,
				taxInvoiceKeyType,
				test,
			} = options
			const query = [
				["brn", brn],
				["taxInvoiceKeyType", taxInvoiceKeyType],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b/tax-invoices/${taxInvoiceKey}/pdf-download-url?${query}`, baseUrl),
				{
					method: "get",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: GetB2bTaxInvoicePdfDownloadUrlError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "FORBIDDEN":
					throw new Errors.ForbiddenError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		updateB2bTaxInvoiceDraft: async (
			options: {
				test?: boolean,
				brn?: string,
				taxInvoiceKey: string,
				taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
				taxInvoice: B2bTaxInvoiceInput,
				modification?: B2bTaxInvoiceModificationUpdateBody,
				memo?: string,
			}
		): Promise<UpdateB2bTaxInvoiceDraftResponse> => {
			const {
				test,
				brn,
				taxInvoiceKey,
				taxInvoiceKeyType,
				taxInvoice,
				modification,
				memo,
			} = options
			const requestBody = JSON.stringify({
				brn,
				taxInvoiceKey,
				taxInvoiceKeyType,
				taxInvoice,
				modification,
				memo,
			})
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b/tax-invoices/draft?${query}`, baseUrl),
				{
					method: "put",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
					body: requestBody,
				},
			)
			if (!response.ok) {
				const errorResponse: UpdateB2bTaxInvoiceDraftError = await response.json()
				switch (errorResponse.type) {
				case "B2B_CANNOT_CHANGE_TAX_TYPE":
					throw new Errors.B2BCannotChangeTaxTypeError(errorResponse)
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_ID_ALREADY_EXISTS":
					throw new Errors.B2bIdAlreadyExistsError(errorResponse)
				case "B2B_MODIFICATION_NOT_PROVIDED":
					throw new Errors.B2bModificationNotProvidedError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_ORIGINAL_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bOriginalTaxInvoiceNotFoundError(errorResponse)
				case "B2B_RECIPIENT_NOT_FOUND":
					throw new Errors.B2bRecipientNotFoundError(errorResponse)
				case "B2B_SUPPLIER_NOT_FOUND":
					throw new Errors.B2bSupplierNotFoundError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_DRAFTED_STATUS":
					throw new Errors.B2bTaxInvoiceNotDraftedStatusError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "B2B_TAX_INVOICE_RECIPIENT_DOCUMENT_KEY_ALREADY_USED":
					throw new Errors.B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError(errorResponse)
				case "B2B_TAX_INVOICE_STATUS_NOT_SENDING_COMPLETED":
					throw new Errors.B2BTaxInvoiceStatusNotSendingCompletedError(errorResponse)
				case "B2B_TAX_INVOICE_SUPPLIER_DOCUMENT_KEY_ALREADY_USED":
					throw new Errors.B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError(errorResponse)
				case "FORBIDDEN":
					throw new Errors.ForbiddenError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		draftB2bTaxInvoice: async (
			options: {
				test?: boolean,
				taxInvoice: B2bTaxInvoiceInput,
				modification?: B2bTaxInvoiceModificationCreateBody,
				memo?: string,
			}
		): Promise<DraftB2bTaxInvoiceResponse> => {
			const {
				test,
				taxInvoice,
				modification,
				memo,
			} = options
			const requestBody = JSON.stringify({
				taxInvoice,
				modification,
				memo,
			})
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b/tax-invoices/draft?${query}`, baseUrl),
				{
					method: "post",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
					body: requestBody,
				},
			)
			if (!response.ok) {
				const errorResponse: DraftB2bTaxInvoiceError = await response.json()
				switch (errorResponse.type) {
				case "B2B_CANNOT_CHANGE_TAX_TYPE":
					throw new Errors.B2BCannotChangeTaxTypeError(errorResponse)
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_ID_ALREADY_EXISTS":
					throw new Errors.B2bIdAlreadyExistsError(errorResponse)
				case "B2B_MODIFICATION_NOT_PROVIDED":
					throw new Errors.B2bModificationNotProvidedError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_ORIGINAL_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bOriginalTaxInvoiceNotFoundError(errorResponse)
				case "B2B_RECIPIENT_NOT_FOUND":
					throw new Errors.B2bRecipientNotFoundError(errorResponse)
				case "B2B_SUPPLIER_NOT_FOUND":
					throw new Errors.B2bSupplierNotFoundError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "B2B_TAX_INVOICE_RECIPIENT_DOCUMENT_KEY_ALREADY_USED":
					throw new Errors.B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError(errorResponse)
				case "B2B_TAX_INVOICE_STATUS_NOT_SENDING_COMPLETED":
					throw new Errors.B2BTaxInvoiceStatusNotSendingCompletedError(errorResponse)
				case "B2B_TAX_INVOICE_SUPPLIER_DOCUMENT_KEY_ALREADY_USED":
					throw new Errors.B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError(errorResponse)
				case "FORBIDDEN":
					throw new Errors.ForbiddenError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		requestB2bTaxInvoice: async (
			options: {
				taxInvoiceKey: string,
				brn?: string,
				taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
				test?: boolean,
			}
		): Promise<RequestB2bTaxInvoiceResponse> => {
			const {
				taxInvoiceKey,
				brn,
				taxInvoiceKeyType,
				test,
			} = options
			const query = [
				["brn", brn],
				["taxInvoiceKeyType", taxInvoiceKeyType],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b/tax-invoices/${taxInvoiceKey}/request?${query}`, baseUrl),
				{
					method: "post",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: requestB2bTaxInvoiceError = await response.json()
				switch (errorResponse.type) {
				case "B2B_CANNOT_CHANGE_TAX_TYPE":
					throw new Errors.B2BCannotChangeTaxTypeError(errorResponse)
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_MODIFICATION_NOT_PROVIDED":
					throw new Errors.B2bModificationNotProvidedError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_ORIGINAL_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bOriginalTaxInvoiceNotFoundError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_DRAFTED_STATUS":
					throw new Errors.B2bTaxInvoiceNotDraftedStatusError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "B2B_TAX_INVOICE_NO_RECIPIENT_DOCUMENT_KEY":
					throw new Errors.B2bTaxInvoiceNoRecipientDocumentKeyError(errorResponse)
				case "B2B_TAX_INVOICE_STATUS_NOT_SENDING_COMPLETED":
					throw new Errors.B2BTaxInvoiceStatusNotSendingCompletedError(errorResponse)
				case "FORBIDDEN":
					throw new Errors.ForbiddenError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		createB2bFileUploadUrl: async (
			fileName: string,
			test?: boolean,
		): Promise<CreateB2bFileUploadUrlPayload> => {
			const requestBody = JSON.stringify({
				fileName,
			})
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b/file-upload-url?${query}`, baseUrl),
				{
					method: "post",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
					body: requestBody,
				},
			)
			if (!response.ok) {
				const errorResponse: CreateB2bFileUploadUrlError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "FORBIDDEN":
					throw new Errors.ForbiddenError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		attachB2bTaxInvoiceFile: async (
			options: {
				taxInvoiceKey: string,
				brn?: string,
				taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
				test?: boolean,
				fileId: string,
			}
		): Promise<void> => {
			const {
				taxInvoiceKey,
				brn,
				taxInvoiceKeyType,
				test,
				fileId,
			} = options
			const requestBody = JSON.stringify({
				fileId,
			})
			const query = [
				["brn", brn],
				["taxInvoiceKeyType", taxInvoiceKeyType],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b/tax-invoices/${taxInvoiceKey}/attach-file?${query}`, baseUrl),
				{
					method: "post",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
					body: requestBody,
				},
			)
			if (!response.ok) {
				const errorResponse: AttachB2bTaxInvoiceFileError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_FILE_NOT_FOUND":
					throw new Errors.B2bFileNotFoundError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_DRAFTED_STATUS":
					throw new Errors.B2bTaxInvoiceNotDraftedStatusError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "FORBIDDEN":
					throw new Errors.ForbiddenError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
		},
		getB2bTaxInvoiceAttachments: async (
			options: {
				taxInvoiceKey: string,
				brn?: string,
				taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
				test?: boolean,
			}
		): Promise<GetB2bTaxInvoiceAttachmentsResponse> => {
			const {
				taxInvoiceKey,
				brn,
				taxInvoiceKeyType,
				test,
			} = options
			const query = [
				["brn", brn],
				["taxInvoiceKeyType", taxInvoiceKeyType],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b/tax-invoices/${taxInvoiceKey}/attachments?${query}`, baseUrl),
				{
					method: "get",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: GetB2bTaxInvoiceAttachmentsError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "FORBIDDEN":
					throw new Errors.ForbiddenError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		deleteB2bTaxInvoiceAttachment: async (
			options: {
				taxInvoiceKey: string,
				attachmentId: string,
				brn?: string,
				taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
				test?: boolean,
			}
		): Promise<void> => {
			const {
				taxInvoiceKey,
				attachmentId,
				brn,
				taxInvoiceKeyType,
				test,
			} = options
			const query = [
				["brn", brn],
				["taxInvoiceKeyType", taxInvoiceKeyType],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b/tax-invoices/${taxInvoiceKey}/attachments/${attachmentId}?${query}`, baseUrl),
				{
					method: "delete",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: DeleteB2bTaxInvoiceAttachmentError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_ATTACHMENT_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceAttachmentNotFoundError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_DRAFTED_STATUS":
					throw new Errors.B2bTaxInvoiceNotDraftedStatusError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "FORBIDDEN":
					throw new Errors.ForbiddenError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
		},
	}
}
export type TaxInvoiceClient = {
	/**
	 * 세금계산서 역발행 즉시 요청
	 *
	 * 공급자에게 세금계산서 역발행을 즉시 요청합니다. 임시저장 API와 역발행 요청 API 기능을 한 번의 프로세스로 처리합니다.
	 *
	 * @throws {@link Errors.B2BCannotChangeTaxTypeError} 세금계산서 과세 유형을 수정할 수 없는 경우
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bIdAlreadyExistsError} ID가 이미 사용중인 경우
	 * @throws {@link Errors.B2bModificationNotProvidedError} 세금계산서 수정 입력 정보를 찾을 수 없는 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bOriginalTaxInvoiceNotFoundError} 원본 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.B2bRecipientNotFoundError} 공급받는자가 존재하지 않은 경우
	 * @throws {@link Errors.B2bSupplierNotFoundError} 공급자가 존재하지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError} 세금계산서에 공급 받는자 문서 번호가 이미 사용 중인 경우
	 * @throws {@link Errors.B2BTaxInvoiceStatusNotSendingCompletedError} 원본 세금계산서가 전송완료 상태가 아닌 경우
	 * @throws {@link Errors.B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError} 세금계산서에 공급자 문서 번호가 이미 사용 중인 경우
	 * @throws {@link Errors.ForbiddenError} 요청이 거절된 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 * @throws {@link Errors.UnknownError} API 응답이 알 수 없는 형식인 경우
	 */
	requestB2bTaxInvoiceReverseIssuance: (
		options: {
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
			/** 세금계산서 생성 요청 정보 */
			taxInvoice: B2bTaxInvoiceInput,
			/** 메모 */
			memo?: string,
			/** 수정 세금계산서 입력 정보 */
			modification?: B2bTaxInvoiceModificationCreateBody,
		}
	) => Promise<RequestB2bTaxInvoiceReverseIssuanceResponse>
	/**
	 * 세금 계산서 조회
	 *
	 * 등록된 세금 계산서를 세금계산서 아이디로 조회합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.ForbiddenError} 요청이 거절된 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 * @throws {@link Errors.UnknownError} API 응답이 알 수 없는 형식인 경우
	 */
	getB2bTaxInvoice: (
		options: {
			/** 세금계산서 문서 번호 */
			taxInvoiceKey: string,
			/** 사업자등록번호 */
			brn?: string,
			/**
			 * 문서 번호 유형
			 *
			 * query 파라미터로 전달된 문서번호 유형. 기본 값은 TAX_INVOICE_ID이며 SUPPLIER, RECIPIENT, TAX_INVOICE_ID을 지원합니다.
			 */
			taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
		}
	) => Promise<B2bTaxInvoice>
	/**
	 * 세금계산서 삭제
	 *
	 * 세금계산서를 삭제합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNonDeletableStatusError} 세금계산서가 삭제 가능한 상태가 아닌 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.ForbiddenError} 요청이 거절된 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 * @throws {@link Errors.UnknownError} API 응답이 알 수 없는 형식인 경우
	 */
	deleteB2bTaxInvoice: (
		options: {
			/** 세금계산서 문서 번호 */
			taxInvoiceKey: string,
			/** 사업자등록번호 */
			brn?: string,
			/**
			 * 문서 번호 유형
			 *
			 * query 파라미터로 전달된 문서번호 유형. 기본 값은 TAX_INVOICE_ID이며 SUPPLIER, RECIPIENT, TAX_INVOICE_ID을 지원합니다.
			 */
			taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
		}
	) => Promise<DeleteB2bTaxInvoiceResponse>
	/**
	 * 세금계산서 발행 승인
	 *
	 * 역발행의 경우 역발행요청(REQUESTED) 상태, 정발행의 경우 임시저장(DRAFTED) 상태의 세금계산서에 대해 발행을 승인합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotRequestedStatusError} 세금계산서가 역발행 대기 상태가 아닌 경우
	 * @throws {@link Errors.B2bTaxInvoiceNoSupplierDocumentKeyError} 세금계산서에 공급자 문서 번호가 기입되지 않은 경우
	 * @throws {@link Errors.ForbiddenError} 요청이 거절된 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 * @throws {@link Errors.UnknownError} API 응답이 알 수 없는 형식인 경우
	 */
	issueB2bTaxInvoice: (
		options: {
			/** 세금계산서 문서 번호 */
			taxInvoiceKey: string,
			/** 사업자등록번호 */
			brn?: string,
			/**
			 * 문서 번호 유형
			 *
			 * query 파라미터로 전달된 문서번호 유형. 기본 값은 TAX_INVOICE_ID이며 SUPPLIER, RECIPIENT, TAX_INVOICE_ID을 지원합니다.
			 */
			taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
			/** 메모 */
			memo?: string,
			/** 이메일 제목 */
			emailSubject?: string,
		}
	) => Promise<IssueB2bTaxInvoiceResponse>
	/**
	 * 세금계산서 국세청 즉시 전송
	 *
	 * 발행이 완료된 세금계산서를 국세청에 즉시 전송합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotIssuedStatusError} 세금계산서가 발행된(ISSUED) 상태가 아닌 경우
	 * @throws {@link Errors.ForbiddenError} 요청이 거절된 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 * @throws {@link Errors.UnknownError} API 응답이 알 수 없는 형식인 경우
	 */
	sendToNtsB2bTaxInvoice: (
		options: {
			/** 세금계산서 문서 번호 */
			taxInvoiceKey: string,
			/** 사업자등록번호 */
			brn?: string,
			/**
			 * 문서 번호 유형
			 *
			 * query 파라미터로 전달된 문서번호 유형. 기본 값은 TAX_INVOICE_ID이며 SUPPLIER, RECIPIENT, TAX_INVOICE_ID을 지원합니다.
			 */
			taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
		}
	) => Promise<SendToNtsB2bTaxInvoiceResponse>
	/**
	 * 세금계산서 역발행 요청 취소 (공급받는자에 의한 취소)
	 *
	 * 공급자가 세금계산서 발행을 승인하기 전에 공급받는자가 해당 역발행 요청을 취소합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotRequestedStatusError} 세금계산서가 역발행 대기 상태가 아닌 경우
	 * @throws {@link Errors.B2bTaxInvoiceNoRecipientDocumentKeyError} 세금계산서에 공급받는자 문서 번호가 기입되지 않은 경우
	 * @throws {@link Errors.ForbiddenError} 요청이 거절된 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 * @throws {@link Errors.UnknownError} API 응답이 알 수 없는 형식인 경우
	 */
	cancelB2bTaxInvoiceRequest: (
		options: {
			/** 세금계산서 문서 번호 */
			taxInvoiceKey: string,
			/** 사업자등록번호 */
			brn?: string,
			/**
			 * 문서 번호 유형
			 *
			 * query 파라미터로 전달된 문서번호 유형. 기본 값은 TAX_INVOICE_ID이며 SUPPLIER, RECIPIENT, TAX_INVOICE_ID을 지원합니다.
			 */
			taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
			/** 메모 */
			memo?: string,
		}
	) => Promise<CancelB2bTaxInvoiceRequestResponse>
	/**
	 * 세금계산서 역발행 취소 (공급자에 의한 취소)
	 *
	 * 발행 완료된 세금계산서를 공급자가 국세청 전송 전에 취소합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotIssuedStatusError} 세금계산서가 발행된(ISSUED) 상태가 아닌 경우
	 * @throws {@link Errors.ForbiddenError} 요청이 거절된 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 * @throws {@link Errors.UnknownError} API 응답이 알 수 없는 형식인 경우
	 */
	cancelB2bTaxInvoiceIssuance: (
		options: {
			/** 세금계산서 문서 번호 */
			taxInvoiceKey: string,
			/** 사업자등록번호 */
			brn?: string,
			/**
			 * 문서 번호 유형
			 *
			 * query 파라미터로 전달된 문서번호 유형. 기본 값은 TAX_INVOICE_ID이며 SUPPLIER, RECIPIENT, TAX_INVOICE_ID을 지원합니다.
			 */
			taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
			/** 메모 */
			memo?: string,
		}
	) => Promise<CancelB2bTaxInvoiceIssuanceResponse>
	/**
	 * 세금계산서 역발행 요청 거부
	 *
	 * 공급자가 공급받는자로부터 요청받은 세금계산서 역발행 건을 거부합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotRequestedStatusError} 세금계산서가 역발행 대기 상태가 아닌 경우
	 * @throws {@link Errors.B2bTaxInvoiceNoSupplierDocumentKeyError} 세금계산서에 공급자 문서 번호가 기입되지 않은 경우
	 * @throws {@link Errors.ForbiddenError} 요청이 거절된 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 * @throws {@link Errors.UnknownError} API 응답이 알 수 없는 형식인 경우
	 */
	refuseB2bTaxInvoiceRequest: (
		options: {
			/** 세금계산서 문서 번호 */
			taxInvoiceKey: string,
			/** 사업자등록번호 */
			brn?: string,
			/**
			 * 문서 번호 유형
			 *
			 * query 파라미터로 전달된 문서번호 유형. 기본 값은 TAX_INVOICE_ID이며 SUPPLIER, RECIPIENT, TAX_INVOICE_ID을 지원합니다.
			 */
			taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
			/** 메모 */
			memo?: string,
		}
	) => Promise<RefuseB2bTaxInvoiceRequestResponse>
	/**
	 * 세금 계산서 다건조회
	 *
	 * 조회 기간 내 등록된 세금 계산서를 다건 조회합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.ForbiddenError} 요청이 거절된 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 * @throws {@link Errors.UnknownError} API 응답이 알 수 없는 형식인 경우
	 */
	getB2bTaxInvoices: (
		options?: {
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
			/**
			 * 페이지 번호
			 *
			 * 0부터 시작하는 페이지 번호. 기본 값은 0.
			 * (int32)
			 */
			pageNumber?: number,
			/**
			 * 페이지 크기
			 *
			 * 각 페이지 당 포함할 객체 수. 기본 값은 500이며 최대 1000까지 요청가능합니다.
			 * (int32)
			 */
			pageSize?: number,
			/** 필터 */
			filter?: GetB2bTaxInvoicesBodyFilter,
		}
	) => Promise<GetB2bTaxInvoicesResponse>
	/**
	 * 세금 계산서 팝업 URL 조회
	 *
	 * 등록된 세금 계산서 팝업 URL을 공급자 혹은 공급받는자 문서번호로 조회합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.ForbiddenError} 요청이 거절된 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 * @throws {@link Errors.UnknownError} API 응답이 알 수 없는 형식인 경우
	 */
	getB2bTaxInvoicePopupUrl: (
		options: {
			/** 세금계산서 문서 번호 */
			taxInvoiceKey: string,
			/** 사업자등록번호 */
			brn?: string,
			/**
			 * 문서 번호 유형
			 *
			 * query 파라미터로 전달된 문서번호 유형. 기본 값은 TAX_INVOICE_ID이며 SUPPLIER, RECIPIENT, TAX_INVOICE_ID을 지원합니다.
			 */
			taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
			/**
			 * 메뉴 포함 여부
			 *
			 * 팝업 URL에 메뉴 레이아웃을 포함 여부를 결정합니다. 기본 값은 true입니다.
			 */
			includeMenu?: boolean,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
		}
	) => Promise<GetB2bTaxInvoicePopupUrlResponse>
	/**
	 * 세금 계산서 프린트 URL 조회
	 *
	 * 등록된 세금 계산서 프린트 URL을 공급자 혹은 공급받는자 문서번호로 조회합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.ForbiddenError} 요청이 거절된 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 * @throws {@link Errors.UnknownError} API 응답이 알 수 없는 형식인 경우
	 */
	getB2bTaxInvoicePrintUrl: (
		options: {
			/** 세금계산서 문서 번호 */
			taxInvoiceKey: string,
			/** 사업자등록번호 */
			brn?: string,
			/**
			 * 문서 번호 유형
			 *
			 * query 파라미터로 전달된 문서번호 유형. 기본 값은 TAX_INVOICE_ID이며 SUPPLIER, RECIPIENT, TAX_INVOICE_ID을 지원합니다.
			 */
			taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
		}
	) => Promise<GetB2bTaxInvoicePrintUrlResponse>
	/**
	 * 세금 계산서 PDF 다운로드 URL 조회
	 *
	 * 등록된 세금 계산서 PDF 다운로드 URL을 공급자 혹은 공급받는자 문서번호로 조회합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.ForbiddenError} 요청이 거절된 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 * @throws {@link Errors.UnknownError} API 응답이 알 수 없는 형식인 경우
	 */
	getB2bTaxInvoicePdfDownloadUrl: (
		options: {
			/** 세금계산서 문서 번호 */
			taxInvoiceKey: string,
			/** 사업자등록번호 */
			brn?: string,
			/**
			 * 문서 번호 유형
			 *
			 * query 파라미터로 전달된 문서번호 유형. 기본 값은 TAX_INVOICE_ID이며 SUPPLIER, RECIPIENT, TAX_INVOICE_ID을 지원합니다.
			 */
			taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
		}
	) => Promise<GetB2bTaxInvoicePdfDownloadUrlResponse>
	/**
	 * 세금계산서 임시저장 수정
	 *
	 * 임시 저장된 세금계산서를 수정합니다.
	 *
	 * @throws {@link Errors.B2BCannotChangeTaxTypeError} 세금계산서 과세 유형을 수정할 수 없는 경우
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bIdAlreadyExistsError} ID가 이미 사용중인 경우
	 * @throws {@link Errors.B2bModificationNotProvidedError} 세금계산서 수정 입력 정보를 찾을 수 없는 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bOriginalTaxInvoiceNotFoundError} 원본 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.B2bRecipientNotFoundError} 공급받는자가 존재하지 않은 경우
	 * @throws {@link Errors.B2bSupplierNotFoundError} 공급자가 존재하지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotDraftedStatusError} 세금계산서가 임시저장 상태가 아닌 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError} 세금계산서에 공급 받는자 문서 번호가 이미 사용 중인 경우
	 * @throws {@link Errors.B2BTaxInvoiceStatusNotSendingCompletedError} 원본 세금계산서가 전송완료 상태가 아닌 경우
	 * @throws {@link Errors.B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError} 세금계산서에 공급자 문서 번호가 이미 사용 중인 경우
	 * @throws {@link Errors.ForbiddenError} 요청이 거절된 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 * @throws {@link Errors.UnknownError} API 응답이 알 수 없는 형식인 경우
	 */
	updateB2bTaxInvoiceDraft: (
		options: {
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
			/**
			 * 사업자등록번호
			 *
			 * taxInvoiceKeyType이 TAX_INVOICE_ID가 아닌 경우 필수 값입니다.
			 */
			brn?: string,
			/** 세금계산서 문서 번호 */
			taxInvoiceKey: string,
			/**
			 * 문서 번호 유형
			 *
			 * 기본 값은 RECIPIENT이며 SUPPLIER, RECIPIENT을 지원합니다.
			 */
			taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
			/** 세금계산서 임시저장 수정 정보 */
			taxInvoice: B2bTaxInvoiceInput,
			/** 수정 세금계산서 입력 정보 */
			modification?: B2bTaxInvoiceModificationUpdateBody,
			/** 메모 */
			memo?: string,
		}
	) => Promise<UpdateB2bTaxInvoiceDraftResponse>
	/**
	 * 세금계산서 임시 저장
	 *
	 * 세금계산서 임시 저장을 요청합니다.
	 *
	 * @throws {@link Errors.B2BCannotChangeTaxTypeError} 세금계산서 과세 유형을 수정할 수 없는 경우
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bIdAlreadyExistsError} ID가 이미 사용중인 경우
	 * @throws {@link Errors.B2bModificationNotProvidedError} 세금계산서 수정 입력 정보를 찾을 수 없는 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bOriginalTaxInvoiceNotFoundError} 원본 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.B2bRecipientNotFoundError} 공급받는자가 존재하지 않은 경우
	 * @throws {@link Errors.B2bSupplierNotFoundError} 공급자가 존재하지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError} 세금계산서에 공급 받는자 문서 번호가 이미 사용 중인 경우
	 * @throws {@link Errors.B2BTaxInvoiceStatusNotSendingCompletedError} 원본 세금계산서가 전송완료 상태가 아닌 경우
	 * @throws {@link Errors.B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError} 세금계산서에 공급자 문서 번호가 이미 사용 중인 경우
	 * @throws {@link Errors.ForbiddenError} 요청이 거절된 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 * @throws {@link Errors.UnknownError} API 응답이 알 수 없는 형식인 경우
	 */
	draftB2bTaxInvoice: (
		options: {
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
			/** 세금계산서 생성 요청 정보 */
			taxInvoice: B2bTaxInvoiceInput,
			/** 수정 세금계산서 입력 정보 */
			modification?: B2bTaxInvoiceModificationCreateBody,
			/** 메모 */
			memo?: string,
		}
	) => Promise<DraftB2bTaxInvoiceResponse>
	/**
	 * 세금계산서 역발행 요청
	 *
	 * 임시저장(REGISTERED) 상태의 역발행 세금계산서를 공급자에게 발행 요청합니다. 요청이 완료되면 (역)발행대기 상태로 전환됩니다.
	 *
	 * @throws {@link Errors.B2BCannotChangeTaxTypeError} 세금계산서 과세 유형을 수정할 수 없는 경우
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bModificationNotProvidedError} 세금계산서 수정 입력 정보를 찾을 수 없는 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bOriginalTaxInvoiceNotFoundError} 원본 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotDraftedStatusError} 세금계산서가 임시저장 상태가 아닌 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNoRecipientDocumentKeyError} 세금계산서에 공급받는자 문서 번호가 기입되지 않은 경우
	 * @throws {@link Errors.B2BTaxInvoiceStatusNotSendingCompletedError} 원본 세금계산서가 전송완료 상태가 아닌 경우
	 * @throws {@link Errors.ForbiddenError} 요청이 거절된 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 * @throws {@link Errors.UnknownError} API 응답이 알 수 없는 형식인 경우
	 */
	requestB2bTaxInvoice: (
		options: {
			/** 세금계산서 문서 번호 */
			taxInvoiceKey: string,
			/** 사업자등록번호 */
			brn?: string,
			/**
			 * 문서 번호 유형
			 *
			 * query 파라미터로 전달된 문서번호 유형. 기본 값은 TAX_INVOICE_ID이며 SUPPLIER, RECIPIENT, TAX_INVOICE_ID을 지원합니다.
			 */
			taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
		}
	) => Promise<RequestB2bTaxInvoiceResponse>
	/**
	 * 파일 업로드 URL 생성
	 *
	 * S3 파일 업로드를 위한 URL을 생성합니다.
	 *
	 * @param test
	 * 테스트 모드 여부
	 *
	 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
	 * @param fileName
	 * 파일 이름
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.ForbiddenError} 요청이 거절된 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 * @throws {@link Errors.UnknownError} API 응답이 알 수 없는 형식인 경우
	 */
	createB2bFileUploadUrl: (
		/** 파일 이름 */
		fileName: string,
		/**
		 * 테스트 모드 여부
		 *
		 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
		 */
		test?: boolean,
	) => Promise<CreateB2bFileUploadUrlPayload>
	/**
	 * 세금계산서 파일 첨부
	 *
	 * 세금계산서에 파일을 첨부합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bFileNotFoundError} 업로드한 파일을 찾을 수 없는 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotDraftedStatusError} 세금계산서가 임시저장 상태가 아닌 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.ForbiddenError} 요청이 거절된 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 * @throws {@link Errors.UnknownError} API 응답이 알 수 없는 형식인 경우
	 */
	attachB2bTaxInvoiceFile: (
		options: {
			/** 세금계산서 문서 번호 */
			taxInvoiceKey: string,
			/** 사업자등록번호 */
			brn?: string,
			/**
			 * 문서 번호 유형
			 *
			 * query 파라미터로 전달된 문서번호 유형. 기본 값은 TAX_INVOICE_ID이며 SUPPLIER, RECIPIENT, TAX_INVOICE_ID을 지원합니다.
			 */
			taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
			/** 파일 아이디 */
			fileId: string,
		}
	) => Promise<void>
	/**
	 * 세금계산서 첨부파일 목록 조회
	 *
	 * 세금계산서에 첨부된 파일 목록을 조회합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.ForbiddenError} 요청이 거절된 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 * @throws {@link Errors.UnknownError} API 응답이 알 수 없는 형식인 경우
	 */
	getB2bTaxInvoiceAttachments: (
		options: {
			/** 세금계산서 문서 번호 */
			taxInvoiceKey: string,
			/** 사업자등록번호 */
			brn?: string,
			/**
			 * 문서 번호 유형
			 *
			 * query 파라미터로 전달된 문서번호 유형. 기본 값은 TAX_INVOICE_ID이며 SUPPLIER, RECIPIENT, TAX_INVOICE_ID을 지원합니다.
			 */
			taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
		}
	) => Promise<GetB2bTaxInvoiceAttachmentsResponse>
	/**
	 * 세금계산서 첨부파일 삭제
	 *
	 * 세금계산서 첨부파일을 삭제합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceAttachmentNotFoundError} 세금계산서의 첨부파일을 찾을 수 없는 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotDraftedStatusError} 세금계산서가 임시저장 상태가 아닌 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.ForbiddenError} 요청이 거절된 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 * @throws {@link Errors.UnknownError} API 응답이 알 수 없는 형식인 경우
	 */
	deleteB2bTaxInvoiceAttachment: (
		options: {
			/** 세금계산서 문서 번호 */
			taxInvoiceKey: string,
			/** 첨부파일 아이디 */
			attachmentId: string,
			/** 사업자등록번호 */
			brn?: string,
			/**
			 * 문서 번호 유형
			 *
			 * query 파라미터로 전달된 문서번호 유형. 기본 값은 TAX_INVOICE_ID이며 SUPPLIER, RECIPIENT, TAX_INVOICE_ID을 지원합니다.
			 */
			taxInvoiceKeyType?: B2bTaxInvoiceKeyType,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
		}
	) => Promise<void>
}


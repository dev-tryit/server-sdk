import type { AttachB2bTaxInvoiceFileError } from "#generated/b2b/AttachB2bTaxInvoiceFileError"
import type { B2bCertificate } from "#generated/b2b/B2bCertificate"
import type { B2bCompanyContact } from "#generated/b2b/B2bCompanyContact"
import type { B2bCompanyContactInput } from "#generated/b2b/B2bCompanyContactInput"
import type { B2bCompanyState } from "#generated/b2b/B2bCompanyState"
import type { B2bMemberCompany } from "#generated/b2b/B2bMemberCompany"
import type { B2bSearchDateType } from "#generated/b2b/B2bSearchDateType"
import type { B2bTaxInvoice } from "#generated/b2b/B2bTaxInvoice"
import type { B2bTaxInvoiceDocumentKeyType } from "#generated/b2b/B2bTaxInvoiceDocumentKeyType"
import type { B2bTaxInvoiceInput } from "#generated/b2b/B2bTaxInvoiceInput"
import type { Bank } from "#generated/common/Bank"
import type { CancelB2bTaxInvoiceIssuanceError } from "#generated/b2b/CancelB2bTaxInvoiceIssuanceError"
import type { CancelB2bTaxInvoiceRequestError } from "#generated/b2b/CancelB2bTaxInvoiceRequestError"
import type { CreateB2bTaxInvoiceFileUploadLinkCreateError } from "#generated/b2b/CreateB2bTaxInvoiceFileUploadLinkCreateError"
import type { CreateB2bTaxInvoiceFileUploadLinkResponse } from "#generated/b2b/CreateB2bTaxInvoiceFileUploadLinkResponse"
import type { DeleteB2bTaxInvoiceAttachmentError } from "#generated/b2b/DeleteB2bTaxInvoiceAttachmentError"
import type { DeleteB2bTaxInvoiceError } from "#generated/b2b/DeleteB2bTaxInvoiceError"
import type { GetB2bAccountHolderError } from "#generated/b2b/GetB2bAccountHolderError"
import type { GetB2bBankAccountHolderResponse } from "#generated/b2b/GetB2bBankAccountHolderResponse"
import type { GetB2bCertificateError } from "#generated/b2b/GetB2bCertificateError"
import type { GetB2bCertificateRegistrationUrlError } from "#generated/b2b/GetB2bCertificateRegistrationUrlError"
import type { GetB2bCertificateRegistrationUrlResponse } from "#generated/b2b/GetB2bCertificateRegistrationUrlResponse"
import type { GetB2bCompanyStateError } from "#generated/b2b/GetB2bCompanyStateError"
import type { GetB2bContactIdExistenceResponse } from "#generated/b2b/GetB2bContactIdExistenceResponse"
import type { GetB2bMemberCompanyContactError } from "#generated/b2b/GetB2bMemberCompanyContactError"
import type { GetB2bMemberCompanyError } from "#generated/b2b/GetB2bMemberCompanyError"
import type { GetB2bTaxInvoiceAttachmentsError } from "#generated/b2b/GetB2bTaxInvoiceAttachmentsError"
import type { GetB2bTaxInvoiceAttachmentsResponse } from "#generated/b2b/GetB2bTaxInvoiceAttachmentsResponse"
import type { GetB2bTaxInvoiceError } from "#generated/b2b/GetB2bTaxInvoiceError"
import type { GetB2bTaxInvoicePdfDownloadUrlError } from "#generated/b2b/GetB2bTaxInvoicePdfDownloadUrlError"
import type { GetB2bTaxInvoicePdfDownloadUrlResponse } from "#generated/b2b/GetB2bTaxInvoicePdfDownloadUrlResponse"
import type { GetB2bTaxInvoicePopupUrlError } from "#generated/b2b/GetB2bTaxInvoicePopupUrlError"
import type { GetB2bTaxInvoicePopupUrlResponse } from "#generated/b2b/GetB2bTaxInvoicePopupUrlResponse"
import type { GetB2bTaxInvoicePrintUrlError } from "#generated/b2b/GetB2bTaxInvoicePrintUrlError"
import type { GetB2bTaxInvoicePrintUrlResponse } from "#generated/b2b/GetB2bTaxInvoicePrintUrlResponse"
import type { GetB2bTaxInvoicesError } from "#generated/b2b/GetB2bTaxInvoicesError"
import type { GetB2bTaxInvoicesResponse } from "#generated/b2b/GetB2bTaxInvoicesResponse"
import type { IssueB2bTaxInvoiceError } from "#generated/b2b/IssueB2bTaxInvoiceError"
import type { RefuseB2bTaxInvoiceRequestError } from "#generated/b2b/RefuseB2bTaxInvoiceRequestError"
import type { RegisterB2bMemberCompanyError } from "#generated/b2b/RegisterB2bMemberCompanyError"
import type { RegisterB2bMemberCompanyResponse } from "#generated/b2b/RegisterB2bMemberCompanyResponse"
import type { RequestB2bTaxInvoiceRegisterError } from "#generated/b2b/RequestB2bTaxInvoiceRegisterError"
import type { RequestB2bTaxInvoiceReverseIssuanceError } from "#generated/b2b/RequestB2bTaxInvoiceReverseIssuanceError"
import type { UpdateB2bMemberCompanyContactError } from "#generated/b2b/UpdateB2bMemberCompanyContactError"
import type { UpdateB2bMemberCompanyContactResponse } from "#generated/b2b/UpdateB2bMemberCompanyContactResponse"
import type { UpdateB2bMemberCompanyError } from "#generated/b2b/UpdateB2bMemberCompanyError"
import type { UpdateB2bMemberCompanyResponse } from "#generated/b2b/UpdateB2bMemberCompanyResponse"
import type { getB2bContactIdExistenceError } from "#generated/b2b/getB2bContactIdExistenceError"
import type { requestB2bTaxInvoiceError } from "#generated/b2b/requestB2bTaxInvoiceError"
import * as Errors from "#generated/errors"
export type { AttachB2bTaxInvoiceFileBody } from "./AttachB2bTaxInvoiceFileBody"
export type { B2bCertificate } from "./B2bCertificate"
export type { B2bCertificateType } from "./B2bCertificateType"
export type { B2bCompanyContact } from "./B2bCompanyContact"
export type { B2bCompanyContactInput } from "./B2bCompanyContactInput"
export type { B2bCompanyState } from "./B2bCompanyState"
export type { B2bCompanyStateBusinessStatus } from "./B2bCompanyStateBusinessStatus"
export type { B2bCompanyStateTaxationType } from "./B2bCompanyStateTaxationType"
export type { B2bMemberCompany } from "./B2bMemberCompany"
export type { B2bModification } from "./B2bModification"
export type { B2bSearchDateType } from "./B2bSearchDateType"
export type { B2bTaxInvoice } from "./B2bTaxInvoice"
export type { B2bTaxInvoiceAdditionalContact } from "./B2bTaxInvoiceAdditionalContact"
export type { B2bTaxInvoiceAttachment } from "./B2bTaxInvoiceAttachment"
export type { B2bTaxInvoiceBeforeSending } from "./B2bTaxInvoiceBeforeSending"
export type { B2bTaxInvoiceCompany } from "./B2bTaxInvoiceCompany"
export type { B2bTaxInvoiceContact } from "./B2bTaxInvoiceContact"
export type { B2bTaxInvoiceDocumentKeyType } from "./B2bTaxInvoiceDocumentKeyType"
export type { B2bTaxInvoiceInput } from "./B2bTaxInvoiceInput"
export type { B2bTaxInvoiceIssuanceCancelled } from "./B2bTaxInvoiceIssuanceCancelled"
export type { B2bTaxInvoiceIssued } from "./B2bTaxInvoiceIssued"
export type { B2bTaxInvoiceItem } from "./B2bTaxInvoiceItem"
export type { B2bTaxInvoiceModificationType } from "./B2bTaxInvoiceModificationType"
export type { B2bTaxInvoicePurposeType } from "./B2bTaxInvoicePurposeType"
export type { B2bTaxInvoiceRegistered } from "./B2bTaxInvoiceRegistered"
export type { B2bTaxInvoiceRequestCancelled } from "./B2bTaxInvoiceRequestCancelled"
export type { B2bTaxInvoiceRequestRefused } from "./B2bTaxInvoiceRequestRefused"
export type { B2bTaxInvoiceRequested } from "./B2bTaxInvoiceRequested"
export type { B2bTaxInvoiceSending } from "./B2bTaxInvoiceSending"
export type { B2bTaxInvoiceSendingCompleted } from "./B2bTaxInvoiceSendingCompleted"
export type { B2bTaxInvoiceSendingFailed } from "./B2bTaxInvoiceSendingFailed"
export type { B2bTaxInvoiceStatus } from "./B2bTaxInvoiceStatus"
export type { B2bTaxInvoiceSummary } from "./B2bTaxInvoiceSummary"
export type { B2bTaxInvoiceWaitingSending } from "./B2bTaxInvoiceWaitingSending"
export type { B2bTaxType } from "./B2bTaxType"
export type { CancelB2bTaxInvoiceIssuanceBody } from "./CancelB2bTaxInvoiceIssuanceBody"
export type { CancelB2bTaxInvoiceRequestBody } from "./CancelB2bTaxInvoiceRequestBody"
export type { CreateB2bTaxInvoiceFileUploadLinkBody } from "./CreateB2bTaxInvoiceFileUploadLinkBody"
export type { CreateB2bTaxInvoiceFileUploadLinkResponse } from "./CreateB2bTaxInvoiceFileUploadLinkResponse"
export type { GetB2bBankAccountHolderResponse } from "./GetB2bBankAccountHolderResponse"
export type { GetB2bCertificateRegistrationUrlResponse } from "./GetB2bCertificateRegistrationUrlResponse"
export type { GetB2bContactIdExistenceResponse } from "./GetB2bContactIdExistenceResponse"
export type { GetB2bTaxInvoiceAttachmentsResponse } from "./GetB2bTaxInvoiceAttachmentsResponse"
export type { GetB2bTaxInvoicePdfDownloadUrlResponse } from "./GetB2bTaxInvoicePdfDownloadUrlResponse"
export type { GetB2bTaxInvoicePopupUrlResponse } from "./GetB2bTaxInvoicePopupUrlResponse"
export type { GetB2bTaxInvoicePrintUrlResponse } from "./GetB2bTaxInvoicePrintUrlResponse"
export type { GetB2bTaxInvoicesResponse } from "./GetB2bTaxInvoicesResponse"
export type { IssueB2bTaxInvoiceRequestBody } from "./IssueB2bTaxInvoiceRequestBody"
export type { RefuseB2bTaxInvoiceRequestBody } from "./RefuseB2bTaxInvoiceRequestBody"
export type { RegisterB2bMemberCompanyBody } from "./RegisterB2bMemberCompanyBody"
export type { RegisterB2bMemberCompanyResponse } from "./RegisterB2bMemberCompanyResponse"
export type { RequestB2bTaxInvoiceRegisterBody } from "./RequestB2bTaxInvoiceRegisterBody"
export type { RequestB2bTaxInvoiceRequestBody } from "./RequestB2bTaxInvoiceRequestBody"
export type { RequestB2bTaxInvoiceReverseIssuanceRequestBody } from "./RequestB2bTaxInvoiceReverseIssuanceRequestBody"
export type { UpdateB2bMemberCompanyBody } from "./UpdateB2bMemberCompanyBody"
export type { UpdateB2bMemberCompanyContactBody } from "./UpdateB2bMemberCompanyContactBody"
export type { UpdateB2bMemberCompanyContactResponse } from "./UpdateB2bMemberCompanyContactResponse"
export type { UpdateB2bMemberCompanyResponse } from "./UpdateB2bMemberCompanyResponse"
/** @ignore */
export function B2BClient(secret: string, userAgent: string, baseUrl?: string, storeId?: string): B2BClient {
	return {
		getB2bMemberCompany: async (
			brn: string,
			test?: boolean,
		): Promise<B2bMemberCompany> => {
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/member-companies/${brn}?${query}`, baseUrl),
				{
					method: "get",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: GetB2bMemberCompanyError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_MEMBER_COMPANY_NOT_FOUND":
					throw new Errors.B2bMemberCompanyNotFoundError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		updateB2bMemberCompany: async (
			options: {
				brn: string,
				test?: boolean,
				name?: string,
				ceoName?: string,
				address?: string,
				businessType?: string,
				businessClass?: string,
			}
		): Promise<UpdateB2bMemberCompanyResponse> => {
			const {
				brn,
				test,
				name,
				ceoName,
				address,
				businessType,
				businessClass,
			} = options
			const requestBody = JSON.stringify({
				name,
				ceoName,
				address,
				businessType,
				businessClass,
			})
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/member-companies/${brn}?${query}`, baseUrl),
				{
					method: "patch",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
					body: requestBody,
				},
			)
			if (!response.ok) {
				const errorResponse: UpdateB2bMemberCompanyError = await response.json()
				switch (errorResponse.type) {
				case "B2B_MEMBER_COMPANY_NOT_FOUND":
					throw new Errors.B2bMemberCompanyNotFoundError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		registerB2bMemberCompany: async (
			company: B2bMemberCompany,
			contact: B2bCompanyContactInput,
			test?: boolean,
		): Promise<RegisterB2bMemberCompanyResponse> => {
			const requestBody = JSON.stringify({
				company,
				contact,
			})
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/member-companies?${query}`, baseUrl),
				{
					method: "post",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
					body: requestBody,
				},
			)
			if (!response.ok) {
				const errorResponse: RegisterB2bMemberCompanyError = await response.json()
				switch (errorResponse.type) {
				case "B2B_COMPANY_ALREADY_REGISTERED":
					throw new Errors.B2bCompanyAlreadyRegisteredError(errorResponse)
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_ID_ALREADY_EXISTS":
					throw new Errors.B2bIdAlreadyExistsError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		getB2bMemberCompanyContact: async (
			brn: string,
			contactId: string,
			test?: boolean,
		): Promise<B2bCompanyContact> => {
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/member-companies/${brn}/contacts/{contactId}?${query}`, baseUrl),
				{
					method: "get",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: GetB2bMemberCompanyContactError = await response.json()
				switch (errorResponse.type) {
				case "B2B_CONTACT_NOT_FOUND":
					throw new Errors.B2bContactNotFoundError(errorResponse)
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_MEMBER_COMPANY_NOT_FOUND":
					throw new Errors.B2bMemberCompanyNotFoundError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		updateB2bMemberCompanyContact: async (
			options: {
				brn: string,
				contactId: string,
				test?: boolean,
				password?: string,
				name?: string,
				phoneNumber?: string,
				email?: string,
			}
		): Promise<UpdateB2bMemberCompanyContactResponse> => {
			const {
				brn,
				contactId,
				test,
				password,
				name,
				phoneNumber,
				email,
			} = options
			const requestBody = JSON.stringify({
				password,
				name,
				phoneNumber,
				email,
			})
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/member-companies/${brn}/contacts/{contactId}?${query}`, baseUrl),
				{
					method: "patch",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
					body: requestBody,
				},
			)
			if (!response.ok) {
				const errorResponse: UpdateB2bMemberCompanyContactError = await response.json()
				switch (errorResponse.type) {
				case "B2B_CONTACT_NOT_FOUND":
					throw new Errors.B2bContactNotFoundError(errorResponse)
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_MEMBER_COMPANY_NOT_FOUND":
					throw new Errors.B2bMemberCompanyNotFoundError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		getB2bCertificateRegistrationUrl: async (
			brn: string,
			test?: boolean,
		): Promise<GetB2bCertificateRegistrationUrlResponse> => {
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/member-companies/${brn}/certificate/registration-url?${query}`, baseUrl),
				{
					method: "get",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: GetB2bCertificateRegistrationUrlError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_MEMBER_COMPANY_NOT_FOUND":
					throw new Errors.B2bMemberCompanyNotFoundError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		getB2bCertificate: async (
			brn: string,
			test?: boolean,
		): Promise<B2bCertificate> => {
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/member-companies/${brn}/certificate?${query}`, baseUrl),
				{
					method: "get",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: GetB2bCertificateError = await response.json()
				switch (errorResponse.type) {
				case "B2B_CERTIFICATE_UNREGISTERED":
					throw new Errors.B2bCertificateUnregisteredError(errorResponse)
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_MEMBER_COMPANY_NOT_FOUND":
					throw new Errors.B2bMemberCompanyNotFoundError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		getB2bContactIdExistence: async (
			contactId: string,
			test?: boolean,
		): Promise<GetB2bContactIdExistenceResponse> => {
			const query = [
				["contactId", contactId],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/member-companies/contacts/id-existence?${query}`, baseUrl),
				{
					method: "get",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: getB2bContactIdExistenceError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		getB2bBankAccountHolder: async (
			bank: Bank,
			accountNumber: string,
			test?: boolean,
		): Promise<GetB2bBankAccountHolderResponse> => {
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/bank-accounts/${bank}/{accountNumber}/holder?${query}`, baseUrl),
				{
					method: "get",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: GetB2bAccountHolderError = await response.json()
				switch (errorResponse.type) {
				case "B2B_BANK_ACCOUNT_NOT_FOUND":
					throw new Errors.B2bBankAccountNotFoundError(errorResponse)
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_FINANCIAL_SYSTEM_COMMUNICATION":
					throw new Errors.B2bFinancialSystemCommunicationError(errorResponse)
				case "B2B_FINANCIAL_SYSTEM_FAILURE":
					throw new Errors.B2bFinancialSystemFailureError(errorResponse)
				case "B2B_FINANCIAL_SYSTEM_UNDER_MAINTENANCE":
					throw new Errors.B2bFinancialSystemUnderMaintenanceError(errorResponse)
				case "B2B_FOREIGN_EXCHANGE_ACCOUNT":
					throw new Errors.B2bForeignExchangeAccountError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_REGULAR_MAINTENANCE_TIME":
					throw new Errors.B2bRegularMaintenanceTimeError(errorResponse)
				case "B2B_SUSPENDED_ACCOUNT":
					throw new Errors.B2bSuspendedAccountError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		getB2bCompanyState: async (
			brn: string,
			test?: boolean,
		): Promise<B2bCompanyState> => {
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/company/${brn}/state?${query}`, baseUrl),
				{
					method: "get",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: GetB2bCompanyStateError = await response.json()
				switch (errorResponse.type) {
				case "B2B_COMPANY_NOT_FOUND":
					throw new Errors.B2bCompanyNotFoundError(errorResponse)
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_HOMETAX_UNDER_MAINTENANCE":
					throw new Errors.B2bHometaxUnderMaintenanceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		requestB2bTaxInvoiceReverseIssuance: async (
			options: {
				test?: boolean,
				taxInvoice: B2bTaxInvoiceInput,
				memo?: string,
			}
		): Promise<B2bTaxInvoice> => {
			const {
				test,
				taxInvoice,
				memo,
			} = options
			const requestBody = JSON.stringify({
				taxInvoice,
				memo,
			})
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/tax-invoices/request-reverse-issuance?${query}`, baseUrl),
				{
					method: "post",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
					body: requestBody,
				},
			)
			if (!response.ok) {
				const errorResponse: RequestB2bTaxInvoiceReverseIssuanceError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_RECIPIENT_NOT_FOUND":
					throw new Errors.B2bRecipientNotFoundError(errorResponse)
				case "B2B_SUPPLIER_NOT_FOUND":
					throw new Errors.B2bSupplierNotFoundError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		getB2bTaxInvoice: async (
			options: {
				documentKey: string,
				brn: string,
				documentKeyType?: B2bTaxInvoiceDocumentKeyType,
				test?: boolean,
			}
		): Promise<B2bTaxInvoice> => {
			const {
				documentKey,
				brn,
				documentKeyType,
				test,
			} = options
			const query = [
				["brn", brn],
				["documentKeyType", documentKeyType],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/tax-invoices/${documentKey}?${query}`, baseUrl),
				{
					method: "get",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: GetB2bTaxInvoiceError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		deleteB2bTaxInvoice: async (
			options: {
				documentKey: string,
				brn: string,
				documentKeyType?: B2bTaxInvoiceDocumentKeyType,
				test?: boolean,
			}
		): Promise<void> => {
			const {
				documentKey,
				brn,
				documentKeyType,
				test,
			} = options
			const query = [
				["brn", brn],
				["documentKeyType", documentKeyType],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/tax-invoices/${documentKey}?${query}`, baseUrl),
				{
					method: "delete",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: DeleteB2bTaxInvoiceError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NON_DELETABLE_STATUS":
					throw new Errors.B2bTaxInvoiceNonDeletableStatusError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
		},
		issueB2bTaxInvoice: async (
			options: {
				test?: boolean,
				brn: string,
				documentKey: string,
				documentKeyType?: B2bTaxInvoiceDocumentKeyType,
				memo?: string,
				emailSubject?: string,
			}
		): Promise<B2bTaxInvoice> => {
			const {
				test,
				brn,
				documentKey,
				documentKeyType,
				memo,
				emailSubject,
			} = options
			const requestBody = JSON.stringify({
				brn,
				documentKey,
				documentKeyType,
				memo,
				emailSubject,
			})
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/tax-invoices/issue?${query}`, baseUrl),
				{
					method: "post",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
					body: requestBody,
				},
			)
			if (!response.ok) {
				const errorResponse: IssueB2bTaxInvoiceError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_REQUESTED_STATUS":
					throw new Errors.B2bTaxInvoiceNotRequestedStatusError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		cancelB2bTaxInvoiceRequest: async (
			options: {
				test?: boolean,
				brn: string,
				documentKey: string,
				documentKeyType?: B2bTaxInvoiceDocumentKeyType,
				memo?: string,
			}
		): Promise<B2bTaxInvoice> => {
			const {
				test,
				brn,
				documentKey,
				documentKeyType,
				memo,
			} = options
			const requestBody = JSON.stringify({
				brn,
				documentKey,
				documentKeyType,
				memo,
			})
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/tax-invoices/cancel-request?${query}`, baseUrl),
				{
					method: "post",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
					body: requestBody,
				},
			)
			if (!response.ok) {
				const errorResponse: CancelB2bTaxInvoiceRequestError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_REQUESTED_STATUS":
					throw new Errors.B2bTaxInvoiceNotRequestedStatusError(errorResponse)
				case "B2B_TAX_INVOICE_NO_RECIPIENT_DOCUMENT_KEY":
					throw new Errors.B2bTaxInvoiceNoRecipientDocumentKeyError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		cancelB2bTaxInvoiceIssuance: async (
			options: {
				test?: boolean,
				brn: string,
				documentKey: string,
				documentKeyType?: B2bTaxInvoiceDocumentKeyType,
				memo?: string,
			}
		): Promise<B2bTaxInvoice> => {
			const {
				test,
				brn,
				documentKey,
				documentKeyType,
				memo,
			} = options
			const requestBody = JSON.stringify({
				brn,
				documentKey,
				documentKeyType,
				memo,
			})
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/tax-invoices/cancel-issuance?${query}`, baseUrl),
				{
					method: "post",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
					body: requestBody,
				},
			)
			if (!response.ok) {
				const errorResponse: CancelB2bTaxInvoiceIssuanceError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_ISSUED_STATUS":
					throw new Errors.B2bTaxInvoiceNotIssuedStatusError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		refuseB2bTaxInvoiceRequest: async (
			options: {
				test?: boolean,
				brn: string,
				documentKey: string,
				documentKeyType?: B2bTaxInvoiceDocumentKeyType,
				memo?: string,
			}
		): Promise<B2bTaxInvoice> => {
			const {
				test,
				brn,
				documentKey,
				documentKeyType,
				memo,
			} = options
			const requestBody = JSON.stringify({
				brn,
				documentKey,
				documentKeyType,
				memo,
			})
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/tax-invoices/refuse-request?${query}`, baseUrl),
				{
					method: "post",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
					body: requestBody,
				},
			)
			if (!response.ok) {
				const errorResponse: RefuseB2bTaxInvoiceRequestError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_REQUESTED_STATUS":
					throw new Errors.B2bTaxInvoiceNotRequestedStatusError(errorResponse)
				case "B2B_TAX_INVOICE_NO_SUPPLIER_DOCUMENT_KEY":
					throw new Errors.B2bTaxInvoiceNoSupplierDocumentKeyError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		getB2bTaxInvoices: async (
			options: {
				brn: string,
				pageNumber?: number,
				pageSize?: number,
				from: string,
				until: string,
				dateType: B2bSearchDateType,
				documentKeyType?: B2bTaxInvoiceDocumentKeyType,
				test?: boolean,
			}
		): Promise<GetB2bTaxInvoicesResponse> => {
			const {
				brn,
				pageNumber,
				pageSize,
				from,
				until,
				dateType,
				documentKeyType,
				test,
			} = options
			const query = [
				["brn", brn],
				["pageNumber", pageNumber],
				["pageSize", pageSize],
				["from", from],
				["until", until],
				["dateType", dateType],
				["documentKeyType", documentKeyType],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/tax-invoices?${query}`, baseUrl),
				{
					method: "get",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: GetB2bTaxInvoicesError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		getB2bTaxInvoicePopupUrl: async (
			options: {
				documentKey: string,
				brn: string,
				documentKeyType?: B2bTaxInvoiceDocumentKeyType,
				includeMenu?: boolean,
				test?: boolean,
			}
		): Promise<GetB2bTaxInvoicePopupUrlResponse> => {
			const {
				documentKey,
				brn,
				documentKeyType,
				includeMenu,
				test,
			} = options
			const query = [
				["brn", brn],
				["documentKeyType", documentKeyType],
				["includeMenu", includeMenu],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/tax-invoices/${documentKey}/popup-url?${query}`, baseUrl),
				{
					method: "get",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: GetB2bTaxInvoicePopupUrlError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		getB2bTaxInvoicePrintUrl: async (
			options: {
				documentKey: string,
				brn: string,
				documentKeyType?: B2bTaxInvoiceDocumentKeyType,
				test?: boolean,
			}
		): Promise<GetB2bTaxInvoicePrintUrlResponse> => {
			const {
				documentKey,
				brn,
				documentKeyType,
				test,
			} = options
			const query = [
				["brn", brn],
				["documentKeyType", documentKeyType],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/tax-invoices/${documentKey}/print-url?${query}`, baseUrl),
				{
					method: "get",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: GetB2bTaxInvoicePrintUrlError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		getB2bTaxInvoicePdfDownloadUrl: async (
			options: {
				documentKey: string,
				brn: string,
				documentKeyType?: B2bTaxInvoiceDocumentKeyType,
				test?: boolean,
			}
		): Promise<GetB2bTaxInvoicePdfDownloadUrlResponse> => {
			const {
				documentKey,
				brn,
				documentKeyType,
				test,
			} = options
			const query = [
				["brn", brn],
				["documentKeyType", documentKeyType],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/tax-invoices/${documentKey}/pdf-download-url?${query}`, baseUrl),
				{
					method: "get",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: GetB2bTaxInvoicePdfDownloadUrlError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		requestB2bTaxInvoiceRegister: async (
			taxInvoice: B2bTaxInvoiceInput,
			test?: boolean,
		): Promise<B2bTaxInvoice> => {
			const requestBody = JSON.stringify({
				taxInvoice,
			})
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/tax-invoices/register?${query}`, baseUrl),
				{
					method: "post",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
					body: requestBody,
				},
			)
			if (!response.ok) {
				const errorResponse: RequestB2bTaxInvoiceRegisterError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_RECIPIENT_NOT_FOUND":
					throw new Errors.B2bRecipientNotFoundError(errorResponse)
				case "B2B_SUPPLIER_NOT_FOUND":
					throw new Errors.B2bSupplierNotFoundError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		requestB2bTaxInvoice: async (
			options: {
				test?: boolean,
				brn: string,
				documentKey: string,
				documentKeyType?: B2bTaxInvoiceDocumentKeyType,
				memo?: string,
			}
		): Promise<B2bTaxInvoice> => {
			const {
				test,
				brn,
				documentKey,
				documentKeyType,
				memo,
			} = options
			const requestBody = JSON.stringify({
				brn,
				documentKey,
				documentKeyType,
				memo,
			})
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/tax-invoices/request?${query}`, baseUrl),
				{
					method: "post",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
					body: requestBody,
				},
			)
			if (!response.ok) {
				const errorResponse: requestB2bTaxInvoiceError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_REGISTERED_STATUS":
					throw new Errors.B2bTaxInvoiceNotRegisteredStatusError(errorResponse)
				case "B2B_TAX_INVOICE_NO_RECIPIENT_DOCUMENT_KEY":
					throw new Errors.B2bTaxInvoiceNoRecipientDocumentKeyError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		createB2bTaxInvoiceFileUploadLink: async (
			fileName: string,
			test?: boolean,
		): Promise<CreateB2bTaxInvoiceFileUploadLinkResponse> => {
			const requestBody = JSON.stringify({
				fileName,
			})
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/tax-invoices/file-upload-link?${query}`, baseUrl),
				{
					method: "post",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
					body: requestBody,
				},
			)
			if (!response.ok) {
				const errorResponse: CreateB2bTaxInvoiceFileUploadLinkCreateError = await response.json()
				switch (errorResponse.type) {
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		attachB2bTaxInvoiceFile: async (
			options: {
				test?: boolean,
				brn: string,
				documentKey: string,
				documentKeyType?: B2bTaxInvoiceDocumentKeyType,
				fileId: string,
			}
		): Promise<void> => {
			const {
				test,
				brn,
				documentKey,
				documentKeyType,
				fileId,
			} = options
			const requestBody = JSON.stringify({
				brn,
				documentKey,
				documentKeyType,
				fileId,
			})
			const query = [
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/tax-invoices/attach-file?${query}`, baseUrl),
				{
					method: "post",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
					body: requestBody,
				},
			)
			if (!response.ok) {
				const errorResponse: AttachB2bTaxInvoiceFileError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_FILE_NOT_FOUND":
					throw new Errors.B2bFileNotFoundError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_REGISTERED_STATUS":
					throw new Errors.B2bTaxInvoiceNotRegisteredStatusError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
		},
		getB2bTaxInvoiceAttachments: async (
			options: {
				documentKey: string,
				brn: string,
				documentKeyType?: B2bTaxInvoiceDocumentKeyType,
				test?: boolean,
			}
		): Promise<GetB2bTaxInvoiceAttachmentsResponse> => {
			const {
				documentKey,
				brn,
				documentKeyType,
				test,
			} = options
			const query = [
				["brn", brn],
				["documentKeyType", documentKeyType],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/tax-invoices/${documentKey}/attachments?${query}`, baseUrl),
				{
					method: "get",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: GetB2bTaxInvoiceAttachmentsError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
			return response.json()
		},
		deleteB2bTaxInvoiceAttachment: async (
			options: {
				documentKey: string,
				attachmentId: string,
				brn: string,
				documentKeyType?: B2bTaxInvoiceDocumentKeyType,
				test?: boolean,
			}
		): Promise<void> => {
			const {
				documentKey,
				attachmentId,
				brn,
				documentKeyType,
				test,
			} = options
			const query = [
				["brn", brn],
				["documentKeyType", documentKeyType],
				["test", test],
			]
				.flatMap(([key, value]) => value == null ? [] : `${key}=${encodeURIComponent(value)}`)
				.join("&")
			const response = await fetch(
				new URL(`/b2b-preview/tax-invoices/${documentKey}/attachments/{attachmentId}?${query}`, baseUrl),
				{
					method: "delete",
					headers: {
						Authorization: `PortOne ${secret}`,
						"User-Agent": userAgent,
					},
				},
			)
			if (!response.ok) {
				const errorResponse: DeleteB2bTaxInvoiceAttachmentError = await response.json()
				switch (errorResponse.type) {
				case "B2B_EXTERNAL_SERVICE":
					throw new Errors.B2bExternalServiceError(errorResponse)
				case "B2B_NOT_ENABLED":
					throw new Errors.B2bNotEnabledError(errorResponse)
				case "B2B_TAX_INVOICE_ATTACHMENT_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceAttachmentNotFoundError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_FOUND":
					throw new Errors.B2bTaxInvoiceNotFoundError(errorResponse)
				case "B2B_TAX_INVOICE_NOT_REGISTERED_STATUS":
					throw new Errors.B2bTaxInvoiceNotRegisteredStatusError(errorResponse)
				case "INVALID_REQUEST":
					throw new Errors.InvalidRequestError(errorResponse)
				case "UNAUTHORIZED":
					throw new Errors.UnauthorizedError(errorResponse)
				}
				throw new Errors.UnknownError(errorResponse)
			}
		},
	}
}
export type B2BClient = {
	/**
	 * 연동 사업자 조회
	 *
	 * 포트원 B2B 서비스에 연동된 사업자를 조회합니다.
	 *
	 * @param brn
	 * 사업자등록번호
	 * @param test
	 * 테스트 모드 여부
	 *
	 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bMemberCompanyNotFoundError} 연동 사업자가 존재하지 않는 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	getB2bMemberCompany: (
		/** 사업자등록번호 */
		brn: string,
		/**
		 * 테스트 모드 여부
		 *
		 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
		 */
		test?: boolean,
	) => Promise<B2bMemberCompany>
	/**
	 * 연동 사업자 정보 수정
	 *
	 * 연동 사업자 정보를 수정합니다.
	 *
	 * @throws {@link Errors.B2bMemberCompanyNotFoundError} 연동 사업자가 존재하지 않는 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	updateB2bMemberCompany: (
		options: {
			/** 사업자등록번호 */
			brn: string,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
			/** 회사명 */
			name?: string,
			/** 대표자 성명 */
			ceoName?: string,
			/** 회사 주소 */
			address?: string,
			/** 업태 */
			businessType?: string,
			/** 업종 */
			businessClass?: string,
		}
	) => Promise<UpdateB2bMemberCompanyResponse>
	/**
	 * 사업자 연동
	 *
	 * 포트원 B2B 서비스에 사업자를 연동합니다.
	 *
	 * @param test
	 * 테스트 모드 여부
	 *
	 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
	 * @param company
	 * 사업자 정보
	 * @param contact
	 * 담당자 정보
	 *
	 * @throws {@link Errors.B2bCompanyAlreadyRegisteredError} 사업자가 이미 연동되어 있는 경우
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bIdAlreadyExistsError} ID가 이미 사용중인 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	registerB2bMemberCompany: (
		/** 사업자 정보 */
		company: B2bMemberCompany,
		/** 담당자 정보 */
		contact: B2bCompanyContactInput,
		/**
		 * 테스트 모드 여부
		 *
		 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
		 */
		test?: boolean,
	) => Promise<RegisterB2bMemberCompanyResponse>
	/**
	 * 담당자 조회
	 *
	 * 연동 사업자에 등록된 담당자를 조회합니다.
	 *
	 * @param brn
	 * 사업자등록번호
	 * @param contactId
	 * 담당자 ID
	 * @param test
	 * 테스트 모드 여부
	 *
	 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
	 *
	 * @throws {@link Errors.B2bContactNotFoundError} 담당자가 존재하지 않는 경우
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bMemberCompanyNotFoundError} 연동 사업자가 존재하지 않는 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	getB2bMemberCompanyContact: (
		/** 사업자등록번호 */
		brn: string,
		/** 담당자 ID */
		contactId: string,
		/**
		 * 테스트 모드 여부
		 *
		 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
		 */
		test?: boolean,
	) => Promise<B2bCompanyContact>
	/**
	 * 담당자 정보 수정
	 *
	 * 담당자 정보를 수정합니다.
	 *
	 * @throws {@link Errors.B2bContactNotFoundError} 담당자가 존재하지 않는 경우
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bMemberCompanyNotFoundError} 연동 사업자가 존재하지 않는 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	updateB2bMemberCompanyContact: (
		options: {
			/** 사업자등록번호 */
			brn: string,
			/** 담당자 ID */
			contactId: string,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
			/** 비밀번호 */
			password?: string,
			/** 담당자 성명 */
			name?: string,
			/** 담당자 핸드폰 번호 */
			phoneNumber?: string,
			/** 담당자 이메일 */
			email?: string,
		}
	) => Promise<UpdateB2bMemberCompanyContactResponse>
	/**
	 * 사업자 인증서 등록 URL 조회
	 *
	 * 연동 사업자의 인증서를 등록하기 위한 URL을 조회합니다.
	 *
	 * @param brn
	 * 사업자등록번호
	 * @param test
	 * 테스트 모드 여부
	 *
	 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bMemberCompanyNotFoundError} 연동 사업자가 존재하지 않는 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	getB2bCertificateRegistrationUrl: (
		/** 사업자등록번호 */
		brn: string,
		/**
		 * 테스트 모드 여부
		 *
		 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
		 */
		test?: boolean,
	) => Promise<GetB2bCertificateRegistrationUrlResponse>
	/**
	 * 인증서 조회
	 *
	 * 연동 사업자의 인증서를 조회합니다.
	 *
	 * @param brn
	 * 사업자등록번호
	 * @param test
	 * 테스트 모드 여부
	 *
	 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
	 *
	 * @throws {@link Errors.B2bCertificateUnregisteredError} 인증서가 등록되어 있지 않은 경우
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bMemberCompanyNotFoundError} 연동 사업자가 존재하지 않는 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	getB2bCertificate: (
		/** 사업자등록번호 */
		brn: string,
		/**
		 * 테스트 모드 여부
		 *
		 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
		 */
		test?: boolean,
	) => Promise<B2bCertificate>
	/**
	 * 담당자 ID 존재 여부 확인
	 *
	 * 담당자 ID가 이미 사용중인지 확인합니다.
	 *
	 * @param contactId
	 * 담당자 ID
	 * @param test
	 * 테스트 모드 여부
	 *
	 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	getB2bContactIdExistence: (
		/** 담당자 ID */
		contactId: string,
		/**
		 * 테스트 모드 여부
		 *
		 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
		 */
		test?: boolean,
	) => Promise<GetB2bContactIdExistenceResponse>
	/**
	 * 예금주 조회
	 *
	 * 원하는 계좌의 예금주를 조회합니다.
	 *
	 * @param bank
	 * 은행
	 * @param accountNumber
	 * '-'를 제외한 계좌 번호
	 * @param test
	 * 테스트 모드 여부
	 *
	 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
	 *
	 * @throws {@link Errors.B2bBankAccountNotFoundError} 계좌가 존재하지 않는 경우
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bFinancialSystemCommunicationError} 금융기관과의 통신에 실패한 경우
	 * @throws {@link Errors.B2bFinancialSystemFailureError} 금융기관 장애
	 * @throws {@link Errors.B2bFinancialSystemUnderMaintenanceError} 금융기관 시스템이 점검 중인 경우
	 * @throws {@link Errors.B2bForeignExchangeAccountError} 계좌 정보 조회가 불가능한 외화 계좌인 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bRegularMaintenanceTimeError} 금융기관 시스템이 정기 점검 중인 경우
	 * @throws {@link Errors.B2bSuspendedAccountError} 정지 계좌인 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	getB2bBankAccountHolder: (
		/** 은행 */
		bank: Bank,
		/** '-'를 제외한 계좌 번호 */
		accountNumber: string,
		/**
		 * 테스트 모드 여부
		 *
		 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
		 */
		test?: boolean,
	) => Promise<GetB2bBankAccountHolderResponse>
	/**
	 * 사업자 상태 조회
	 *
	 * 원하는 사업자의 상태를 조회합니다. 포트원 B2B 서비스에 연동 및 등록되지 않은 사업자도 조회 가능합니다.
	 *
	 * @param brn
	 * 사업자등록번호
	 * @param test
	 * 테스트 모드 여부
	 *
	 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
	 *
	 * @throws {@link Errors.B2bCompanyNotFoundError} 사업자가 존재하지 않는 경우
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bHometaxUnderMaintenanceError} 홈택스가 점검중이거나 순단이 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	getB2bCompanyState: (
		/** 사업자등록번호 */
		brn: string,
		/**
		 * 테스트 모드 여부
		 *
		 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
		 */
		test?: boolean,
	) => Promise<B2bCompanyState>
	/**
	 * 세금계산서 역발행 요청
	 *
	 * 공급자에게 세금계산서 역발행을 요청합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bRecipientNotFoundError} 공급받는자가 존재하지 않은 경우
	 * @throws {@link Errors.B2bSupplierNotFoundError} 공급자가 존재하지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	requestB2bTaxInvoiceReverseIssuance: (
		options: {
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
			/** 세금계산서 생성 요청 정보 */
			taxInvoice: B2bTaxInvoiceInput,
			/** 메모 */
			memo?: string,
		}
	) => Promise<B2bTaxInvoice>
	/**
	 * 세금 계산서 조회
	 *
	 * 등록된 세금 계산서를 공급자 혹은 공급받는자 문서번호로 조회합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	getB2bTaxInvoice: (
		options: {
			/** 세금계산서 문서 번호 */
			documentKey: string,
			/** 사업자등록번호 */
			brn: string,
			/**
			 * 문서 번호 유형
			 *
			 * path 파라미터로 전달된 문서번호 유형. 기본 값은 RECIPIENT이며 SUPPLIER, RECIPIENT을 지원합니다.
			 */
			documentKeyType?: B2bTaxInvoiceDocumentKeyType,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
		}
	) => Promise<B2bTaxInvoice>
	/**
	 * 세금계산서 삭제
	 *
	 * 세금계산서를 삭제합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNonDeletableStatusError} 세금계산서가 삭제 가능한 상태가 아닌 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	deleteB2bTaxInvoice: (
		options: {
			/** 세금계산서 문서 번호 */
			documentKey: string,
			/** 사업자등록번호 */
			brn: string,
			/**
			 * 문서 번호 유형
			 *
			 * path 파라미터로 전달된 문서번호 유형. 기본 값은 RECIPIENT이며 SUPPLIER, RECIPIENT을 지원합니다.
			 */
			documentKeyType?: B2bTaxInvoiceDocumentKeyType,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
		}
	) => Promise<void>
	/**
	 * 세금계산서 발행
	 *
	 * 역발행의 경우 역발행요청(REQUESTED) 상태, 정발행의 경우 임시저장(REGISTERED) 상태의 세금계산서를 발행합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotRequestedStatusError} 세금계산서가 역발행 대기 상태가 아닌 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	issueB2bTaxInvoice: (
		options: {
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
			/** 사업자등록번호 */
			brn: string,
			/** 세금계산서 문서 번호 */
			documentKey: string,
			/**
			 * 문서 번호 유형
			 *
			 * 기본 값은 RECIPIENT이며 SUPPLIER, RECIPIENT을 지원합니다.
			 */
			documentKeyType?: B2bTaxInvoiceDocumentKeyType,
			/** 메모 */
			memo?: string,
			/** 이메일 제목 */
			emailSubject?: string,
		}
	) => Promise<B2bTaxInvoice>
	/**
	 * 세금계산서 역발행 요청 취소
	 *
	 * 공급받는자가 공급자에게 세금계산서 역발행 요청한 것을 취소합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotRequestedStatusError} 세금계산서가 역발행 대기 상태가 아닌 경우
	 * @throws {@link Errors.B2bTaxInvoiceNoRecipientDocumentKeyError} 세금계산서에 공급받는자 문서 번호가 기입되지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	cancelB2bTaxInvoiceRequest: (
		options: {
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
			/** 사업자등록번호 */
			brn: string,
			/** 세금계산서 문서 번호 */
			documentKey: string,
			/**
			 * 문서 번호 유형
			 *
			 * 기본 값은 RECIPIENT이며 SUPPLIER, RECIPIENT을 지원합니다.
			 */
			documentKeyType?: B2bTaxInvoiceDocumentKeyType,
			/** 메모 */
			memo?: string,
		}
	) => Promise<B2bTaxInvoice>
	/**
	 * 세금계산서 역발행 취소
	 *
	 * 공급자가 발행 완료한 세금계산서를 국세청 전송 전 취소합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotIssuedStatusError} 세금계산서가 발행된(ISSUED) 상태가 아닌 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	cancelB2bTaxInvoiceIssuance: (
		options: {
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
			/** 사업자등록번호 */
			brn: string,
			/** 세금계산서 문서 번호 */
			documentKey: string,
			/**
			 * 문서 번호 유형
			 *
			 * 기본 값은 RECIPIENT이며 SUPPLIER, RECIPIENT을 지원합니다.
			 */
			documentKeyType?: B2bTaxInvoiceDocumentKeyType,
			/** 메모 */
			memo?: string,
		}
	) => Promise<B2bTaxInvoice>
	/**
	 * 세금계산서 역발행 요청 거부
	 *
	 * 공급자가 공급받는자로부터 요청받은 세금계산서 역발행 건을 거부합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotRequestedStatusError} 세금계산서가 역발행 대기 상태가 아닌 경우
	 * @throws {@link Errors.B2bTaxInvoiceNoSupplierDocumentKeyError} 세금계산서에 공급자 문서 번호가 기입되지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	refuseB2bTaxInvoiceRequest: (
		options: {
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
			/** 사업자등록번호 */
			brn: string,
			/** 세금계산서 문서 번호 */
			documentKey: string,
			/**
			 * 문서 번호 유형
			 *
			 * 기본 값은 RECIPIENT이며 SUPPLIER, RECIPIENT을 지원합니다.
			 */
			documentKeyType?: B2bTaxInvoiceDocumentKeyType,
			/** 메모 */
			memo?: string,
		}
	) => Promise<B2bTaxInvoice>
	/**
	 * 세금 계산서 다건조회
	 *
	 * 조회 기간 내 등록된 세금 계산서를 다건 조회합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	getB2bTaxInvoices: (
		options: {
			/** 사업자등록번호 */
			brn: string,
			/**
			 * 페이지 번호
			 *
			 * 0부터 시작하는 페이지 번호. 기본 값은 0.
			 * (int32)
			 */
			pageNumber?: number,
			/**
			 * 페이지 크기
			 *
			 * 각 페이지 당 포함할 객체 수. 기본 값은 500이며 최대 1000까지 요청가능합니다.
			 * (int32)
			 */
			pageSize?: number,
			/** 조회 시작일 */
			from: string,
			/** 조회 종료일 */
			until: string,
			/** 조회 기간 기준 */
			dateType: B2bSearchDateType,
			/**
			 * 문서 번호 유형
			 *
			 * path 파라미터로 전달된 문서번호 유형. 기본 값은 RECIPIENT이며 SUPPLIER, RECIPIENT을 지원합니다.
			 */
			documentKeyType?: B2bTaxInvoiceDocumentKeyType,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
		}
	) => Promise<GetB2bTaxInvoicesResponse>
	/**
	 * 세금 계산서 팝업 URL 조회
	 *
	 * 등록된 세금 계산서 팝업 URL을 공급자 혹은 공급받는자 문서번호로 조회합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	getB2bTaxInvoicePopupUrl: (
		options: {
			/** 세금계산서 문서 번호 */
			documentKey: string,
			/** 사업자등록번호 */
			brn: string,
			/**
			 * 문서 번호 유형
			 *
			 * path 파라미터로 전달된 문서번호 유형. 기본 값은 RECIPIENT이며 SUPPLIER, RECIPIENT을 지원합니다.
			 */
			documentKeyType?: B2bTaxInvoiceDocumentKeyType,
			/**
			 * 메뉴 포함 여부
			 *
			 * 팝업 URL에 메뉴 레이아웃을 포함 여부를 결정합니다. 기본 값은 true입니다.
			 */
			includeMenu?: boolean,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
		}
	) => Promise<GetB2bTaxInvoicePopupUrlResponse>
	/**
	 * 세금 계산서 프린트 URL 조회
	 *
	 * 등록된 세금 계산서 프린트 URL을 공급자 혹은 공급받는자 문서번호로 조회합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	getB2bTaxInvoicePrintUrl: (
		options: {
			/** 세금계산서 문서 번호 */
			documentKey: string,
			/** 사업자등록번호 */
			brn: string,
			/**
			 * 문서 번호 유형
			 *
			 * path 파라미터로 전달된 문서번호 유형. 기본 값은 RECIPIENT이며 SUPPLIER, RECIPIENT을 지원합니다.
			 */
			documentKeyType?: B2bTaxInvoiceDocumentKeyType,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
		}
	) => Promise<GetB2bTaxInvoicePrintUrlResponse>
	/**
	 * 세금 계산서 PDF 다운로드 URL 조회
	 *
	 * 등록된 세금 계산서 PDF 다운로드 URL을 공급자 혹은 공급받는자 문서번호로 조회합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	getB2bTaxInvoicePdfDownloadUrl: (
		options: {
			/** 세금계산서 문서 번호 */
			documentKey: string,
			/** 사업자등록번호 */
			brn: string,
			/**
			 * 문서 번호 유형
			 *
			 * path 파라미터로 전달된 문서번호 유형. 기본 값은 RECIPIENT이며 SUPPLIER, RECIPIENT을 지원합니다.
			 */
			documentKeyType?: B2bTaxInvoiceDocumentKeyType,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
		}
	) => Promise<GetB2bTaxInvoicePdfDownloadUrlResponse>
	/**
	 * 세금계산서 임시 저장
	 *
	 * 세금계산서 임시 저장을 요청합니다.
	 *
	 * @param test
	 * 테스트 모드 여부
	 *
	 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
	 * @param taxInvoice
	 * 세금계산서 생성 요청 정보
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bRecipientNotFoundError} 공급받는자가 존재하지 않은 경우
	 * @throws {@link Errors.B2bSupplierNotFoundError} 공급자가 존재하지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	requestB2bTaxInvoiceRegister: (
		/** 세금계산서 생성 요청 정보 */
		taxInvoice: B2bTaxInvoiceInput,
		/**
		 * 테스트 모드 여부
		 *
		 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
		 */
		test?: boolean,
	) => Promise<B2bTaxInvoice>
	/**
	 * 세금계산서 역발행 요청
	 *
	 * 임시저장(REGISTERED) 상태의 역발행 세금계산서를 공급자에게 발행 요청합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotRegisteredStatusError} 세금계산서가 임시저장 상태가 아닌 경우
	 * @throws {@link Errors.B2bTaxInvoiceNoRecipientDocumentKeyError} 세금계산서에 공급받는자 문서 번호가 기입되지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	requestB2bTaxInvoice: (
		options: {
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
			/** 사업자등록번호 */
			brn: string,
			/** 세금계산서 문서 번호 */
			documentKey: string,
			/**
			 * 문서 번호 유형
			 *
			 * 기본 값은 RECIPIENT이며 SUPPLIER, RECIPIENT을 지원합니다.
			 */
			documentKeyType?: B2bTaxInvoiceDocumentKeyType,
			/** 메모 */
			memo?: string,
		}
	) => Promise<B2bTaxInvoice>
	/**
	 * 세금계산서 파일 업로드 링크 생성
	 *
	 * 세금계산서의 첨부파일를 업로드할 링크를 생성합니다.
	 *
	 * @param test
	 * 테스트 모드 여부
	 *
	 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
	 * @param fileName
	 * 파일 이름
	 *
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	createB2bTaxInvoiceFileUploadLink: (
		/** 파일 이름 */
		fileName: string,
		/**
		 * 테스트 모드 여부
		 *
		 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
		 */
		test?: boolean,
	) => Promise<CreateB2bTaxInvoiceFileUploadLinkResponse>
	/**
	 * 세금계산서 파일 첨부
	 *
	 * 세금계산서에 파일을 첨부합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bFileNotFoundError} 업로드한 파일을 찾을 수 없는 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotRegisteredStatusError} 세금계산서가 임시저장 상태가 아닌 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	attachB2bTaxInvoiceFile: (
		options: {
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
			/**
			 * 사업자등록번호
			 *
			 * `-` 없이 숫자 10자리로 구성됩니다.
			 */
			brn: string,
			/** 세금계산서 문서 번호 */
			documentKey: string,
			/**
			 * 문서 번호 유형
			 *
			 * 기본 값은 RECIPIENT이며 SUPPLIER, RECIPIENT을 지원합니다.
			 */
			documentKeyType?: B2bTaxInvoiceDocumentKeyType,
			/** 파일 아이디 */
			fileId: string,
		}
	) => Promise<void>
	/**
	 * 세금계산서 첨부파일 목록 조회
	 *
	 * 세금계산서에 첨부된 파일 목록을 조회합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	getB2bTaxInvoiceAttachments: (
		options: {
			/** 세금계산서 문서 번호 */
			documentKey: string,
			/** 사업자등록번호 */
			brn: string,
			/**
			 * 문서 번호 유형
			 *
			 * path 파라미터로 전달된 문서번호 유형. 기본 값은 RECIPIENT이며 SUPPLIER, RECIPIENT을 지원합니다.
			 */
			documentKeyType?: B2bTaxInvoiceDocumentKeyType,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
		}
	) => Promise<GetB2bTaxInvoiceAttachmentsResponse>
	/**
	 * 세금계산서 첨부파일 삭제
	 *
	 * 세금계산서 첨부파일을 삭제합니다.
	 *
	 * @throws {@link Errors.B2bExternalServiceError} 외부 서비스에서 에러가 발생한 경우
	 * @throws {@link Errors.B2bNotEnabledError} B2B 기능이 활성화되지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceAttachmentNotFoundError} 세금계산서의 첨부파일을 찾을 수 없는 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotFoundError} 세금계산서가 존재하지 않은 경우
	 * @throws {@link Errors.B2bTaxInvoiceNotRegisteredStatusError} 세금계산서가 임시저장 상태가 아닌 경우
	 * @throws {@link Errors.InvalidRequestError} 요청된 입력 정보가 유효하지 않은 경우
	 * @throws {@link Errors.UnauthorizedError} 인증 정보가 올바르지 않은 경우
	 */
	deleteB2bTaxInvoiceAttachment: (
		options: {
			/** 세금계산서 문서 번호 */
			documentKey: string,
			/** 첨부파일 아이디 */
			attachmentId: string,
			/** 사업자등록번호 */
			brn: string,
			/**
			 * 문서 번호 유형
			 *
			 * path 파라미터로 전달된 문서번호 유형. 기본 값은 RECIPIENT이며 SUPPLIER, RECIPIENT을 지원합니다.
			 */
			documentKeyType?: B2bTaxInvoiceDocumentKeyType,
			/**
			 * 테스트 모드 여부
			 *
			 * true 이면 테스트 모드로 실행되며, false 이거나 주어지지 않은 경우 테스트 모드를 사용하지 않습니다.
			 */
			test?: boolean,
		}
	) => Promise<void>
}

